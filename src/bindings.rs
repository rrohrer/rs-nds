/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const _LIBNDS_MAJOR_: u32 = 1;
pub const _LIBNDS_MINOR_: u32 = 7;
pub const _LIBNDS_PATCH_: u32 = 3;
pub const _LIBNDS_STRING: &'static [u8; 21usize] = b"libNDS Release 1.7.3\0";
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"3.1.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 1;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long64: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT64: &'static [u8; 3usize] = b"ll\0";
pub const __FAST8: &'static [u8; 3usize] = b"hh\0";
pub const __FAST16: &'static [u8; 2usize] = b"h\0";
pub const __FAST64: &'static [u8; 3usize] = b"ll\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST64: &'static [u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const COPY_MODE_HWORD: u32 = 0;
pub const COPY_MODE_COPY: u32 = 0;
pub const CARD_CR1_ENABLE: u32 = 128;
pub const CARD_CR1_IRQ: u32 = 64;
pub const SPI_EEPROM_WRSR: u32 = 1;
pub const SPI_EEPROM_PP: u32 = 2;
pub const SPI_EEPROM_READ: u32 = 3;
pub const SPI_EEPROM_WRDI: u32 = 4;
pub const SPI_EEPROM_RDSR: u32 = 5;
pub const SPI_EEPROM_WREN: u32 = 6;
pub const SPI_EEPROM_PW: u32 = 10;
pub const SPI_EEPROM_FAST: u32 = 11;
pub const SPI_EEPROM_RDID: u32 = 159;
pub const SPI_EEPROM_RDP: u32 = 171;
pub const SPI_EEPROM_DPD: u32 = 185;
pub const CARD_ACTIVATE: u32 = 2147483648;
pub const CARD_WR: u32 = 1073741824;
pub const CARD_nRESET: u32 = 536870912;
pub const CARD_SEC_LARGE: u32 = 268435456;
pub const CARD_CLK_SLOW: u32 = 134217728;
pub const CARD_SEC_CMD: u32 = 4194304;
pub const CARD_SEC_SEED: u32 = 32768;
pub const CARD_SEC_EN: u32 = 16384;
pub const CARD_SEC_DAT: u32 = 8192;
pub const CARD_BUSY: u32 = 2147483648;
pub const CARD_DATA_READY: u32 = 8388608;
pub const CARD_CMD_DUMMY: u32 = 159;
pub const CARD_CMD_HEADER_READ: u32 = 0;
pub const CARD_CMD_HEADER_CHIPID: u32 = 144;
pub const CARD_CMD_ACTIVATE_BF: u32 = 60;
pub const CARD_CMD_ACTIVATE_SEC: u32 = 64;
pub const CARD_CMD_SECURE_CHIPID: u32 = 16;
pub const CARD_CMD_SECURE_READ: u32 = 32;
pub const CARD_CMD_DISABLE_SEC: u32 = 96;
pub const CARD_CMD_DATA_MODE: u32 = 160;
pub const CARD_CMD_DATA_READ: u32 = 183;
pub const CARD_CMD_DATA_CHIPID: u32 = 184;
pub const CARD_ENABLE: u32 = 32768;
pub const CARD_SPI_ENABLE: u32 = 8192;
pub const CARD_SPI_BUSY: u32 = 128;
pub const CARD_SPI_HOLD: u32 = 64;
pub const CARD_SPICNTH_ENABLE: u32 = 128;
pub const CARD_SPICNTH_IRQ: u32 = 64;
pub const DMA_START_NOW: u32 = 0;
pub const DMA_START_CARD: u32 = 671088640;
pub const DMA_START_FIFO: u32 = 939524096;
pub const DMA_DISP_FIFO: u32 = 536870912;
pub const DMA_16_BIT: u32 = 0;
pub const DMA_SRC_INC: u32 = 0;
pub const DMA_DST_INC: u32 = 0;
pub const DMA_DST_RESET: u32 = 6291456;
pub const MAX_INTERRUPTS: u32 = 25;
pub const BUS_OWNER_ARM9: u32 = 1;
pub const BUS_OWNER_ARM7: u32 = 0;
pub const ARGV_MAGIC: u32 = 1600221799;
pub const BOOTSIG: u64 = 7094704827215605602;
pub const BUS_CLOCK: u32 = 33513982;
pub const TIMER_ENABLE: u32 = 128;
pub const TIMER_IRQ_REQ: u32 = 64;
pub const TIMER_CASCADE: u32 = 4;
pub const TIMER_DIV_1: u32 = 0;
pub const TIMER_DIV_64: u32 = 1;
pub const TIMER_DIV_256: u32 = 2;
pub const TIMER_DIV_1024: u32 = 3;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const M_MXFAST: u32 = 1;
pub const M_NLBLKS: u32 = 2;
pub const M_GRAIN: u32 = 3;
pub const M_KEEP: u32 = 4;
pub const M_TRIM_THRESHOLD: i32 = -1;
pub const M_TOP_PAD: i32 = -2;
pub const M_MMAP_THRESHOLD: i32 = -3;
pub const M_MMAP_MAX: i32 = -4;
pub const SCREEN_HEIGHT: u32 = 192;
pub const SCREEN_WIDTH: u32 = 256;
pub const VRAM_ENABLE: u32 = 128;
pub const ENABLE_3D: u32 = 8;
pub const DISPLAY_ENABLE_SHIFT: u32 = 8;
pub const DISPLAY_BG0_ACTIVE: u32 = 256;
pub const DISPLAY_BG1_ACTIVE: u32 = 512;
pub const DISPLAY_BG2_ACTIVE: u32 = 1024;
pub const DISPLAY_BG3_ACTIVE: u32 = 2048;
pub const DISPLAY_SPR_ACTIVE: u32 = 4096;
pub const DISPLAY_WIN0_ON: u32 = 8192;
pub const DISPLAY_WIN1_ON: u32 = 16384;
pub const DISPLAY_SPR_WIN_ON: u32 = 32768;
pub const DISPLAY_SPR_HBLANK: u32 = 8388608;
pub const DISPLAY_SPR_1D_LAYOUT: u32 = 16;
pub const DISPLAY_SPR_1D: u32 = 16;
pub const DISPLAY_SPR_2D: u32 = 0;
pub const DISPLAY_SPR_1D_BMP: u32 = 64;
pub const DISPLAY_SPR_2D_BMP_128: u32 = 0;
pub const DISPLAY_SPR_2D_BMP_256: u32 = 32;
pub const DISPLAY_SPR_1D_SIZE_32: u32 = 0;
pub const DISPLAY_SPR_1D_SIZE_64: u32 = 1048576;
pub const DISPLAY_SPR_1D_SIZE_128: u32 = 2097152;
pub const DISPLAY_SPR_1D_SIZE_256: u32 = 3145728;
pub const DISPLAY_SPR_1D_BMP_SIZE_128: u32 = 0;
pub const DISPLAY_SPR_1D_BMP_SIZE_256: u32 = 4194304;
pub const DISPLAY_SPRITE_ATTR_MASK: u32 = 2154823792;
pub const DISPLAY_SPR_EXT_PALETTE: u32 = 2147483648;
pub const DISPLAY_BG_EXT_PALETTE: u32 = 1073741824;
pub const DISPLAY_SCREEN_OFF: u32 = 128;
pub const BLEND_NONE: u32 = 0;
pub const BLEND_ALPHA: u32 = 64;
pub const BLEND_FADE_WHITE: u32 = 128;
pub const BLEND_FADE_BLACK: u32 = 192;
pub const BLEND_SRC_BG0: u32 = 1;
pub const BLEND_SRC_BG1: u32 = 2;
pub const BLEND_SRC_BG2: u32 = 4;
pub const BLEND_SRC_BG3: u32 = 8;
pub const BLEND_SRC_SPRITE: u32 = 16;
pub const BLEND_SRC_BACKDROP: u32 = 32;
pub const BLEND_DST_BG0: u32 = 256;
pub const BLEND_DST_BG1: u32 = 512;
pub const BLEND_DST_BG2: u32 = 1024;
pub const BLEND_DST_BG3: u32 = 2048;
pub const BLEND_DST_SPRITE: u32 = 4096;
pub const BLEND_DST_BACKDROP: u32 = 8192;
pub const DCAP_MODE_A: u32 = 0;
pub const DCAP_MODE_B: u32 = 1;
pub const DCAP_MODE_BLEND: u32 = 2;
pub const DCAP_SRC_A_COMPOSITED: u32 = 0;
pub const DCAP_SRC_A_3DONLY: u32 = 1;
pub const DCAP_SRC_B_VRAM: u32 = 0;
pub const DCAP_SRC_B_DISPFIFO: u32 = 1;
pub const DCAP_SIZE_128x128: u32 = 0;
pub const DCAP_SIZE_256x64: u32 = 1;
pub const DCAP_SIZE_256x128: u32 = 2;
pub const DCAP_SIZE_256x192: u32 = 3;
pub const DCAP_BANK_VRAM_A: u32 = 0;
pub const DCAP_BANK_VRAM_B: u32 = 1;
pub const DCAP_BANK_VRAM_C: u32 = 2;
pub const DCAP_BANK_VRAM_D: u32 = 3;
pub const MAP_BASE_SHIFT: u32 = 8;
pub const TILE_BASE_SHIFT: u32 = 2;
pub const DEGREES_IN_CIRCLE: u32 = 32768;
pub const DIV_64_64: u32 = 2;
pub const DIV_64_32: u32 = 1;
pub const DIV_32_32: u32 = 0;
pub const DIV_BUSY: u32 = 32768;
pub const SQRT_64: u32 = 1;
pub const SQRT_32: u32 = 0;
pub const SQRT_BUSY: u32 = 32768;
pub const LUT_SIZE: u32 = 32768;
pub const LUT_MASK: u32 = 32767;
pub const MAX_TEXTURES: u32 = 2048;
pub const GL_MAX_DEPTH: u32 = 32767;
pub const GL_FALSE: u32 = 0;
pub const GL_TRUE: u32 = 1;
pub const ATTR0_NORMAL: u32 = 0;
pub const ATTR0_ROTSCALE: u32 = 256;
pub const ATTR0_DISABLED: u32 = 512;
pub const ATTR0_ROTSCALE_DOUBLE: u32 = 768;
pub const ATTR0_TYPE_NORMAL: u32 = 0;
pub const ATTR0_TYPE_BLENDED: u32 = 1024;
pub const ATTR0_TYPE_WINDOWED: u32 = 2048;
pub const ATTR0_BMP: u32 = 3072;
pub const ATTR0_MOSAIC: u32 = 4096;
pub const ATTR0_COLOR_16: u32 = 0;
pub const ATTR0_COLOR_256: u32 = 8192;
pub const ATTR0_SQUARE: u32 = 0;
pub const ATTR0_WIDE: u32 = 16384;
pub const ATTR0_TALL: u32 = 32768;
pub const ATTR1_FLIP_X: u32 = 4096;
pub const ATTR1_FLIP_Y: u32 = 8192;
pub const ATTR1_SIZE_8: u32 = 0;
pub const ATTR1_SIZE_16: u32 = 16384;
pub const ATTR1_SIZE_32: u32 = 32768;
pub const ATTR1_SIZE_64: u32 = 49152;
pub const SPRITE_COUNT: u32 = 128;
pub const MATRIX_COUNT: u32 = 32;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const F_OK: u32 = 0;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _SC_ARG_MAX: u32 = 0;
pub const _SC_CHILD_MAX: u32 = 1;
pub const _SC_CLK_TCK: u32 = 2;
pub const _SC_NGROUPS_MAX: u32 = 3;
pub const _SC_OPEN_MAX: u32 = 4;
pub const _SC_JOB_CONTROL: u32 = 5;
pub const _SC_SAVED_IDS: u32 = 6;
pub const _SC_VERSION: u32 = 7;
pub const _SC_PAGESIZE: u32 = 8;
pub const _SC_PAGE_SIZE: u32 = 8;
pub const _SC_NPROCESSORS_CONF: u32 = 9;
pub const _SC_NPROCESSORS_ONLN: u32 = 10;
pub const _SC_PHYS_PAGES: u32 = 11;
pub const _SC_AVPHYS_PAGES: u32 = 12;
pub const _SC_MQ_OPEN_MAX: u32 = 13;
pub const _SC_MQ_PRIO_MAX: u32 = 14;
pub const _SC_RTSIG_MAX: u32 = 15;
pub const _SC_SEM_NSEMS_MAX: u32 = 16;
pub const _SC_SEM_VALUE_MAX: u32 = 17;
pub const _SC_SIGQUEUE_MAX: u32 = 18;
pub const _SC_TIMER_MAX: u32 = 19;
pub const _SC_TZNAME_MAX: u32 = 20;
pub const _SC_ASYNCHRONOUS_IO: u32 = 21;
pub const _SC_FSYNC: u32 = 22;
pub const _SC_MAPPED_FILES: u32 = 23;
pub const _SC_MEMLOCK: u32 = 24;
pub const _SC_MEMLOCK_RANGE: u32 = 25;
pub const _SC_MEMORY_PROTECTION: u32 = 26;
pub const _SC_MESSAGE_PASSING: u32 = 27;
pub const _SC_PRIORITIZED_IO: u32 = 28;
pub const _SC_REALTIME_SIGNALS: u32 = 29;
pub const _SC_SEMAPHORES: u32 = 30;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 31;
pub const _SC_SYNCHRONIZED_IO: u32 = 32;
pub const _SC_TIMERS: u32 = 33;
pub const _SC_AIO_LISTIO_MAX: u32 = 34;
pub const _SC_AIO_MAX: u32 = 35;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 36;
pub const _SC_DELAYTIMER_MAX: u32 = 37;
pub const _SC_THREAD_KEYS_MAX: u32 = 38;
pub const _SC_THREAD_STACK_MIN: u32 = 39;
pub const _SC_THREAD_THREADS_MAX: u32 = 40;
pub const _SC_TTY_NAME_MAX: u32 = 41;
pub const _SC_THREADS: u32 = 42;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 43;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 44;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 45;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 46;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 47;
pub const _SC_THREAD_PRIO_CEILING: u32 = 47;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 48;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 49;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 50;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 51;
pub const _SC_LOGIN_NAME_MAX: u32 = 52;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 53;
pub const _SC_ADVISORY_INFO: u32 = 54;
pub const _SC_ATEXIT_MAX: u32 = 55;
pub const _SC_BARRIERS: u32 = 56;
pub const _SC_BC_BASE_MAX: u32 = 57;
pub const _SC_BC_DIM_MAX: u32 = 58;
pub const _SC_BC_SCALE_MAX: u32 = 59;
pub const _SC_BC_STRING_MAX: u32 = 60;
pub const _SC_CLOCK_SELECTION: u32 = 61;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 62;
pub const _SC_CPUTIME: u32 = 63;
pub const _SC_EXPR_NEST_MAX: u32 = 64;
pub const _SC_HOST_NAME_MAX: u32 = 65;
pub const _SC_IOV_MAX: u32 = 66;
pub const _SC_IPV6: u32 = 67;
pub const _SC_LINE_MAX: u32 = 68;
pub const _SC_MONOTONIC_CLOCK: u32 = 69;
pub const _SC_RAW_SOCKETS: u32 = 70;
pub const _SC_READER_WRITER_LOCKS: u32 = 71;
pub const _SC_REGEXP: u32 = 72;
pub const _SC_RE_DUP_MAX: u32 = 73;
pub const _SC_SHELL: u32 = 74;
pub const _SC_SPAWN: u32 = 75;
pub const _SC_SPIN_LOCKS: u32 = 76;
pub const _SC_SPORADIC_SERVER: u32 = 77;
pub const _SC_SS_REPL_MAX: u32 = 78;
pub const _SC_SYMLOOP_MAX: u32 = 79;
pub const _SC_THREAD_CPUTIME: u32 = 80;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 81;
pub const _SC_TIMEOUTS: u32 = 82;
pub const _SC_TRACE: u32 = 83;
pub const _SC_TRACE_EVENT_FILTER: u32 = 84;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 85;
pub const _SC_TRACE_INHERIT: u32 = 86;
pub const _SC_TRACE_LOG: u32 = 87;
pub const _SC_TRACE_NAME_MAX: u32 = 88;
pub const _SC_TRACE_SYS_MAX: u32 = 89;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 90;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 91;
pub const _SC_V7_ILP32_OFF32: u32 = 92;
pub const _SC_V6_ILP32_OFF32: u32 = 92;
pub const _SC_XBS5_ILP32_OFF32: u32 = 92;
pub const _SC_V7_ILP32_OFFBIG: u32 = 93;
pub const _SC_V6_ILP32_OFFBIG: u32 = 93;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 93;
pub const _SC_V7_LP64_OFF64: u32 = 94;
pub const _SC_V6_LP64_OFF64: u32 = 94;
pub const _SC_XBS5_LP64_OFF64: u32 = 94;
pub const _SC_V7_LPBIG_OFFBIG: u32 = 95;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 95;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 95;
pub const _SC_XOPEN_CRYPT: u32 = 96;
pub const _SC_XOPEN_ENH_I18N: u32 = 97;
pub const _SC_XOPEN_LEGACY: u32 = 98;
pub const _SC_XOPEN_REALTIME: u32 = 99;
pub const _SC_STREAM_MAX: u32 = 100;
pub const _SC_PRIORITY_SCHEDULING: u32 = 101;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 102;
pub const _SC_XOPEN_SHM: u32 = 103;
pub const _SC_XOPEN_STREAMS: u32 = 104;
pub const _SC_XOPEN_UNIX: u32 = 105;
pub const _SC_XOPEN_VERSION: u32 = 106;
pub const _SC_2_CHAR_TERM: u32 = 107;
pub const _SC_2_C_BIND: u32 = 108;
pub const _SC_2_C_DEV: u32 = 109;
pub const _SC_2_FORT_DEV: u32 = 110;
pub const _SC_2_FORT_RUN: u32 = 111;
pub const _SC_2_LOCALEDEF: u32 = 112;
pub const _SC_2_PBS: u32 = 113;
pub const _SC_2_PBS_ACCOUNTING: u32 = 114;
pub const _SC_2_PBS_CHECKPOINT: u32 = 115;
pub const _SC_2_PBS_LOCATE: u32 = 116;
pub const _SC_2_PBS_MESSAGE: u32 = 117;
pub const _SC_2_PBS_TRACK: u32 = 118;
pub const _SC_2_SW_DEV: u32 = 119;
pub const _SC_2_UPE: u32 = 120;
pub const _SC_2_VERSION: u32 = 121;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: u32 = 122;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: u32 = 123;
pub const _SC_XOPEN_UUCP: u32 = 124;
pub const _SC_LEVEL1_ICACHE_SIZE: u32 = 125;
pub const _SC_LEVEL1_ICACHE_ASSOC: u32 = 126;
pub const _SC_LEVEL1_ICACHE_LINESIZE: u32 = 127;
pub const _SC_LEVEL1_DCACHE_SIZE: u32 = 128;
pub const _SC_LEVEL1_DCACHE_ASSOC: u32 = 129;
pub const _SC_LEVEL1_DCACHE_LINESIZE: u32 = 130;
pub const _SC_LEVEL2_CACHE_SIZE: u32 = 131;
pub const _SC_LEVEL2_CACHE_ASSOC: u32 = 132;
pub const _SC_LEVEL2_CACHE_LINESIZE: u32 = 133;
pub const _SC_LEVEL3_CACHE_SIZE: u32 = 134;
pub const _SC_LEVEL3_CACHE_ASSOC: u32 = 135;
pub const _SC_LEVEL3_CACHE_LINESIZE: u32 = 136;
pub const _SC_LEVEL4_CACHE_SIZE: u32 = 137;
pub const _SC_LEVEL4_CACHE_ASSOC: u32 = 138;
pub const _SC_LEVEL4_CACHE_LINESIZE: u32 = 139;
pub const _SC_POSIX_26_VERSION: u32 = 140;
pub const _PC_LINK_MAX: u32 = 0;
pub const _PC_MAX_CANON: u32 = 1;
pub const _PC_MAX_INPUT: u32 = 2;
pub const _PC_NAME_MAX: u32 = 3;
pub const _PC_PATH_MAX: u32 = 4;
pub const _PC_PIPE_BUF: u32 = 5;
pub const _PC_CHOWN_RESTRICTED: u32 = 6;
pub const _PC_NO_TRUNC: u32 = 7;
pub const _PC_VDISABLE: u32 = 8;
pub const _PC_ASYNC_IO: u32 = 9;
pub const _PC_PRIO_IO: u32 = 10;
pub const _PC_SYNC_IO: u32 = 11;
pub const _PC_FILESIZEBITS: u32 = 12;
pub const _PC_2_SYMLINKS: u32 = 13;
pub const _PC_SYMLINK_MAX: u32 = 14;
pub const _PC_ALLOC_SIZE_MIN: u32 = 15;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 16;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 17;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 18;
pub const _PC_REC_XFER_ALIGN: u32 = 19;
pub const _PC_TIMESTAMP_RESOLUTION: u32 = 20;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __int_least8_t = ::std::os::raw::c_schar;
pub type __uint_least8_t = ::std::os::raw::c_uchar;
pub type __int_least16_t = ::std::os::raw::c_short;
pub type __uint_least16_t = ::std::os::raw::c_ushort;
pub type __int_least32_t = ::std::os::raw::c_int;
pub type __uint_least32_t = ::std::os::raw::c_uint;
pub type __int_least64_t = ::std::os::raw::c_longlong;
pub type __uint_least64_t = ::std::os::raw::c_ulonglong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __uintptr_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type int_fast16_t = ::std::os::raw::c_short;
pub type uint_fast16_t = ::std::os::raw::c_ushort;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
#[doc = "! 8 bit unsigned integer."]
pub type uint8 = u8;
#[doc = "! 16 bit unsigned integer."]
pub type uint16 = u16;
#[doc = "! 32 bit unsigned integer."]
pub type uint32 = u32;
#[doc = "! 64 bit unsigned integer."]
pub type uint64 = u64;
#[doc = "! 8 bit signed integer."]
pub type int8 = i8;
#[doc = "! 16 bit signed integer."]
pub type int16 = i16;
#[doc = "! 32 bit signed integer."]
pub type int32 = i32;
#[doc = "! 64 bit signed integer."]
pub type int64 = i64;
#[doc = "! 32 bit signed floating point number."]
pub type float32 = f32;
#[doc = "! 64 bit signed floating point number."]
pub type float64 = f64;
#[doc = "! 8 bit volatile unsigned integer."]
pub type vuint8 = u8;
#[doc = "! 16 bit volatile unsigned integer."]
pub type vuint16 = u16;
#[doc = "! 32 bit volatile unsigned integer."]
pub type vuint32 = u32;
#[doc = "! 64 bit volatile unsigned integer."]
pub type vuint64 = u64;
#[doc = "! 8 bit volatile signed integer."]
pub type vint8 = i8;
#[doc = "! 16 bit volatile signed integer."]
pub type vint16 = i16;
#[doc = "! 32 bit volatile signed integer."]
pub type vint32 = i32;
#[doc = "! 64 bit volatile signed integer."]
pub type vint64 = i64;
#[doc = "! 32 bit volatile signed floating point number."]
pub type vfloat32 = float32;
#[doc = "! 64 bit volatile signed floating point number."]
pub type vfloat64 = float64;
#[doc = "! 8 bit unsigned integer."]
pub type byte = u8;
#[doc = "! 8 bit signed integer."]
pub type s8 = i8;
#[doc = "! 16 bit signed integer."]
pub type s16 = i16;
#[doc = "! 32 bit signed integer."]
pub type s32 = i32;
#[doc = "! 64 bit signed integer."]
pub type s64 = i64;
#[doc = "! 8 bit volatile unsigned integer."]
pub type vu8 = u8;
#[doc = "! 16 bit volatile unsigned integer."]
pub type vu16 = u16;
#[doc = "! 32 bit volatile unsigned integer."]
pub type vu32 = u32;
#[doc = "! 64 bit volatile unsigned integer."]
pub type vu64 = u64;
#[doc = "! 8 bit volatile signed integer."]
pub type vs8 = s8;
#[doc = "! 16 bit volatile signed integer."]
pub type vs16 = s16;
#[doc = "! 32 bit volatile signed integer."]
pub type vs32 = s32;
#[doc = "! 64 bit volatile signed integer."]
pub type vs64 = s64;
pub type sec_t = u32;
#[doc = "! a function pointer that takes no arguments and doesn't return anything."]
pub type VoidFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type IntFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type fp = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "\t\\brief Should return the header of a compressed stream of bytes."]
#[doc = ""]
#[doc = "The result is a word, with the size of decompressed data in bits 8-31,"]
#[doc = "and bits 0-7 are ignored.  This value is also returned by the bios function, unless getResult is non-NULL and returns a negative value."]
#[doc = "This useally returns the 4 bytes that source points to."]
#[doc = ""]
#[doc = "\\param source \tA pointer to the compressed data."]
#[doc = "\\param dest\t\tA pointer to the space where the decompressed data should be copied to."]
#[doc = "\\param arg\t\tA callback value that gets passed to the bios function."]
#[doc = "\\return The header of the compressed data containing the length of the data and the compression type."]
pub type getHeaderCallback = ::core::option::Option<
    unsafe extern "C" fn(source: *mut u8, dest: *mut u16, arg: u32) -> ::std::os::raw::c_int,
>;
#[doc = "\t\\brief Should verify the result after data got decompressed."]
#[doc = ""]
#[doc = "getResult is used to provide a result for the bios function, given the source pointer after all data has been read"]
#[doc = "(or if getSize < 0). Its value is only returned if negative, otherwise the typical result is used, so it is likely"]
#[doc = "some sort of error-checking procedure."]
#[doc = ""]
#[doc = "\\param source The current source address."]
#[doc = "\\return 0 if it went right, or a negative number if something went wrong. value will be returned from bios function if value is negative."]
pub type getResultCallback =
    ::core::option::Option<unsafe extern "C" fn(source: *mut u8) -> ::std::os::raw::c_int>;
#[doc = "\t\\brief Should returns a raw byte of the stream."]
#[doc = "\\param source A pointer to the byte."]
#[doc = "\\return A byte."]
pub type getByteCallback = ::core::option::Option<unsafe extern "C" fn(source: *mut u8) -> u8>;
#[doc = "! A struct that contains callback function pointers used by the decompression functions."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DecompressionStream {
    #[doc = "!< gets called to get the header of the stream."]
    pub getSize: getHeaderCallback,
    #[doc = "!< gets called to verify the result afterwards, can be NULL (no callback)."]
    pub getResult: getResultCallback,
    #[doc = "!< gets called to get a byte of the compressed data."]
    pub readByte: getByteCallback,
}
#[test]
fn bindgen_test_layout_DecompressionStream() {
    assert_eq!(
        ::core::mem::size_of::<DecompressionStream>(),
        24usize,
        concat!("Size of: ", stringify!(DecompressionStream))
    );
    assert_eq!(
        ::core::mem::align_of::<DecompressionStream>(),
        1usize,
        concat!("Alignment of ", stringify!(DecompressionStream))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DecompressionStream>())).getSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DecompressionStream),
            "::",
            stringify!(getSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DecompressionStream>())).getResult as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DecompressionStream),
            "::",
            stringify!(getResult)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DecompressionStream>())).readByte as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DecompressionStream),
            "::",
            stringify!(readByte)
        )
    );
}
pub type TDecompressionStream = DecompressionStream;
#[doc = "! A struct and struct pointer with information about unpacking data."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UnpackStruct {
    #[doc = "!< in bytes"]
    pub sourceSize: uint16,
    #[doc = "!< 1,2,4 or 8 bits."]
    pub sourceWidth: uint8,
    #[doc = "!< 1,2,4,8,16 or 32 bits."]
    pub destWidth: uint8,
    #[doc = "!< bits 0-30 are added to all non-zero destination writes, unless bit 31 is set, which does it for zeros too."]
    pub dataOffset: uint32,
}
#[test]
fn bindgen_test_layout_UnpackStruct() {
    assert_eq!(
        ::core::mem::size_of::<UnpackStruct>(),
        8usize,
        concat!("Size of: ", stringify!(UnpackStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<UnpackStruct>(),
        1usize,
        concat!("Alignment of ", stringify!(UnpackStruct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UnpackStruct>())).sourceSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UnpackStruct),
            "::",
            stringify!(sourceSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UnpackStruct>())).sourceWidth as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UnpackStruct),
            "::",
            stringify!(sourceWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UnpackStruct>())).destWidth as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(UnpackStruct),
            "::",
            stringify!(destWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UnpackStruct>())).dataOffset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UnpackStruct),
            "::",
            stringify!(dataOffset)
        )
    );
}
pub type TUnpackStruct = UnpackStruct;
pub type PUnpackStruct = *mut UnpackStruct;
extern "C" {
    #[doc = "\\brief resets the DS."]
    pub fn swiSoftReset();
}
extern "C" {
    #[doc = "\\brief delays the code."]
    #[doc = ""]
    #[doc = "Delays for for a period X + Y*duration where X is the swi overhead and Y is a cycle of"]
    #[doc = "<CODE><PRE>"]
    #[doc = "loop:"]
    #[doc = "sub r0, #1"]
    #[doc = "bgt loop"]
    #[doc = "</PRE></CODE>"]
    #[doc = "of thumb fetches in BIOS memory"]
    #[doc = "\\param duration length of delay"]
    #[doc = "\\note Duration should be 1 or more, a duration of 0 is a huge delay."]
    pub fn swiDelay(duration: uint32);
}
extern "C" {
    #[doc = "\\brief divides 2 numbers."]
    #[doc = "\\param numerator\tsigned integer to divide"]
    #[doc = "\\param divisor\t\tsigned integer to divide by"]
    #[doc = "\\return numerator / divisor"]
    pub fn swiDivide(
        numerator: ::std::os::raw::c_int,
        divisor: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief calculate the remainder of an division."]
    #[doc = "\\param numerator\tsigned integer to divide"]
    #[doc = "\\param divisor\t\tsigned integer to divide by"]
    #[doc = "\\return numerator % divisor"]
    pub fn swiRemainder(
        numerator: ::std::os::raw::c_int,
        divisor: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief divides 2 numbers and stores both the result and the remainder."]
    #[doc = ""]
    #[doc = "\\param numerator\tsigned integer to divide"]
    #[doc = "\\param divisor\t\tsigned integer to divide by"]
    #[doc = "\\param result\t\tpointer to integer set to numerator / divisor"]
    #[doc = "\\param remainder \tpointer to integer set to numerator % divisor"]
    pub fn swiDivMod(
        numerator: ::std::os::raw::c_int,
        divisor: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
        remainder: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\t\\brief copies or fills some memory."]
    #[doc = "\\param source \tpointer to transfer source or pointer to value to fill the memory with."]
    #[doc = "\\param dest\t\tpointer to transfer destination."]
    #[doc = "\\param flags\tbits(0-20): size of data to copy/fill in words,"]
    #[doc = "or'd with the copy mode size (word or halfword) and type (copy or fill)."]
    pub fn swiCopy(
        source: *const ::core::ffi::c_void,
        dest: *mut ::core::ffi::c_void,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\t\\brief copies or fills some memory."]
    #[doc = "can only copy in word chunks."]
    #[doc = "\\param source\tpointer to transfer source or pointer to value to fill the memory with."]
    #[doc = "\\param dest\t\tpointer to transfer destination."]
    #[doc = "\\param flags\tbits(0-20): size of data to copy/fill in words,"]
    #[doc = "or'd with the type (copy or fill)."]
    #[doc = ""]
    #[doc = "\\note Transfers more quickly than swiCopy, but has higher interrupt latency."]
    pub fn swiFastCopy(
        source: *const ::core::ffi::c_void,
        dest: *mut ::core::ffi::c_void,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\t\\brief calculates the square root."]
    #[doc = "\\param value the value to calculate."]
    #[doc = "\\return the square root of the value as an integer."]
    #[doc = "\\note use fixed point math if you want more accuracy."]
    pub fn swiSqrt(value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\brief calculates a CRC-16 checksum."]
    #[doc = "\\param crc \t\tstarting CRC-16 value."]
    #[doc = "\\param data \tpointer to data (processed nibble by nibble)"]
    #[doc = "\\param size \tsize in bytes."]
    #[doc = ""]
    #[doc = "\\return the CRC-16 after the data has been processed."]
    pub fn swiCRC16(crc: uint16, data: *mut ::core::ffi::c_void, size: uint32) -> uint16;
}
extern "C" {
    #[doc = "\t\\brief returns 0 if running on a nintendo hardware debugger."]
    #[doc = "\\return 0 if running on a debugger (8 MB of ram instead of 4 MB), else some other number."]
    pub fn swiIsDebugger() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\brief Unpack data stored in multiple elements in a byte to a larger space."]
    #[doc = ""]
    #[doc = "i.e. 8 elements per byte (i.e. b/w font), into 1 element per byte."]
    #[doc = ""]
    #[doc = "\\param source\t\t\tSource address."]
    #[doc = "\\param destination\t\tdestination address (word aligned)."]
    #[doc = "\\param params\t\t\tpointer to an UnpackStruct."]
    pub fn swiUnpackBits(source: *mut uint8, destination: *mut uint32, params: PUnpackStruct);
}
extern "C" {
    #[doc = "\t\\brief Decompresses LZSS compressed data."]
    #[doc = "\\param source\t\tpointer to a header word, followed by compressed data."]
    #[doc = "bit 0-7 of header is ignored."]
    #[doc = "bit 8-31 of header is size of uncompressed data in bytes."]
    #[doc = "\\param destination\tdestination address."]
    #[doc = "\\note Writes data a byte at a time."]
    #[doc = "\\see decompress.h"]
    pub fn swiDecompressLZSSWram(
        source: *mut ::core::ffi::c_void,
        destination: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "\t\\brief Decompresses LZSS compressed data vram safe."]
    #[doc = ""]
    #[doc = "\\param source\t\t\tPointer to source data (always goes through the function pointers, so could just be an offset)."]
    #[doc = "\\param destination\t\tPointer to destination."]
    #[doc = "\\param toGetSize\t\tCallback value that is passed to getHeaderCallback function pointer."]
    #[doc = "\\param stream\t\t\tPointer to struct with callback function pointers."]
    #[doc = ""]
    #[doc = "\\return The length of the decompressed data, or a signed errorcode from the Open/Close functions."]
    #[doc = "\\note Writes data a halfword at a time."]
    #[doc = "\\see decompress.h"]
    pub fn swiDecompressLZSSVram(
        source: *mut ::core::ffi::c_void,
        destination: *mut ::core::ffi::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swiDecompressLZSSVramNTR(
        source: *mut ::core::ffi::c_void,
        destination: *mut ::core::ffi::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swiDecompressLZSSVramTWL(
        source: *mut ::core::ffi::c_void,
        destination: *mut ::core::ffi::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\brief Decompresses Huffman compressed data."]
    #[doc = ""]
    #[doc = "\\param source\t\t\tPointer to source data (always goes through the function pointers, so could just be an offset)."]
    #[doc = "\\param destination\t\tPointer to destination."]
    #[doc = "\\param toGetSize\t\tCallback value that is passed to getHeaderCallback function pointer."]
    #[doc = "\\param stream\t\t\tPointer to struct with callback function pointers."]
    #[doc = ""]
    #[doc = "\\return The length of the decompressed data, or a signed errorcode from the Open/Close functions."]
    #[doc = "\\see decompress.h"]
    pub fn swiDecompressHuffman(
        source: *mut ::core::ffi::c_void,
        destination: *mut ::core::ffi::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\brief Decompresses RLE compressed data."]
    #[doc = ""]
    #[doc = "compressed data format:"]
    #[doc = "bit(7): 0= uncompressed, 1= compressed."]
    #[doc = "bit(0-6) when uncompressed: run length - 1, followed by run_length bytes of true data."]
    #[doc = "bit(0-6) when compressed: run length - 3, followed by one byte of true data, to be repeated."]
    #[doc = ""]
    #[doc = "\\param source\t\tpointer to a header word, followed by compressed data."]
    #[doc = "bit 0-7 of header is ignored."]
    #[doc = "bit 8-31 of header is size of uncompressed data in bytes."]
    #[doc = "\\param destination\tdestination address."]
    #[doc = "\\note Writes data a byte at a time."]
    #[doc = "\\see decompress.h"]
    pub fn swiDecompressRLEWram(
        source: *mut ::core::ffi::c_void,
        destination: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "\t\\brief Decompresses RLE compressed data vram safe."]
    #[doc = ""]
    #[doc = "compressed data format:"]
    #[doc = "bit(7): 0= uncompressed, 1= compressed."]
    #[doc = "bit(0-6) when uncompressed: run length - 1, followed by run_length bytes of true data."]
    #[doc = "bit(0-6) when compressed: run length - 3, followed by one byte of true data, to be repeated."]
    #[doc = ""]
    #[doc = "\\param source\t\t\tPointer to source data (always goes through the function pointers, so could just be an offset)."]
    #[doc = "\\param destination\t\tPointer to destination."]
    #[doc = "\\param toGetSize\t\tCallback value that is passed to getHeaderCallback function pointer."]
    #[doc = "\\param stream\t\t\tPointer to struct with callback function pointers."]
    #[doc = ""]
    #[doc = "\\return The length of the decompressed data, or a signed errorcode from the Open/Close functions."]
    #[doc = "\\note Writes data a halfword at a time."]
    #[doc = "\\see decompress.h"]
    pub fn swiDecompressRLEVram(
        source: *mut ::core::ffi::c_void,
        destination: *mut ::core::ffi::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\brief wait for any interrupt."]
    #[doc = ""]
    #[doc = "\\note ARM9 exclusive."]
    pub fn swiWaitForIRQ();
}
extern "C" {
    #[doc = "\t\\brief Writes a word of the data to 0x04000300:32"]
    #[doc = ""]
    #[doc = "\\param data the word to write."]
    #[doc = "\\note This is on the ARM9, but works differently then the ARM7 function!"]
    pub fn swiSetHaltCR(data: uint32);
}
extern "C" {
    #[doc = "\t\\brief Decodes a stream of bytes based on the difference of the bytes."]
    #[doc = "\\param source \t\tPointer to a header word, followed by encoded data."]
    #[doc = "word(31..8) = size of data (in bytes)."]
    #[doc = "word(7..0) = ignored."]
    #[doc = "\\param destination\tDestination address."]
    #[doc = ""]
    #[doc = "\\note Writes data a byte at a time."]
    #[doc = "\\note ARM9 exclusive."]
    pub fn swiDecodeDelta8(source: *mut ::core::ffi::c_void, destination: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = "\t\\brief Decodes a stream of bytes based on the difference of the bytes."]
    #[doc = "\\param source\t\tPointer to a header word, followed by encoded data."]
    #[doc = "word(31..8) = size of data (in bytes)."]
    #[doc = "word(7..0) = ignored."]
    #[doc = "\\param destination\tDestination address."]
    #[doc = ""]
    #[doc = "\\note Writes data a halfword at a time."]
    #[doc = "\\note ARM9 exclusive."]
    pub fn swiDecodeDelta16(
        source: *mut ::core::ffi::c_void,
        destination: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn enableSlot1();
}
extern "C" {
    pub fn disableSlot1();
}
extern "C" {
    pub fn cardWriteCommand(command: *const u8);
}
extern "C" {
    pub fn cardPolledTransfer(flags: u32, destination: *mut u32, length: u32, command: *const u8);
}
extern "C" {
    pub fn cardStartTransfer(
        command: *const u8,
        destination: *mut u32,
        channel: ::std::os::raw::c_int,
        flags: u32,
    );
}
extern "C" {
    pub fn cardWriteAndRead(command: *const u8, flags: u32) -> uint32;
}
extern "C" {
    pub fn cardParamCommand(
        command: u8,
        parameter: u32,
        flags: u32,
        destination: *mut u32,
        length: u32,
    );
}
extern "C" {
    pub fn cardReadHeader(header: *mut u8);
}
extern "C" {
    pub fn cardReadID(flags: u32) -> u32;
}
extern "C" {
    pub fn cardReset();
}
extern "C" {
    pub fn cardReadEeprom(address: u32, data: *mut u8, length: u32, addrtype: u32);
}
extern "C" {
    pub fn cardWriteEeprom(address: u32, data: *mut u8, length: u32, addrtype: u32);
}
extern "C" {
    pub fn cardEepromReadID() -> u32;
}
extern "C" {
    pub fn cardEepromCommand(command: u8) -> u8;
}
extern "C" {
    pub fn cardEepromGetType() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cardEepromGetSize() -> u32;
}
extern "C" {
    pub fn cardEepromChipErase();
}
extern "C" {
    pub fn cardEepromSectorErase(address: u32);
}
extern "C" {
    pub fn nocashWrite(message: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\brief Send a message to the no$gba debug window"]
    #[doc = "\\param message The message to send"]
    pub fn nocashMessage(message: *const ::std::os::raw::c_char);
}
#[doc = "< vertical blank interrupt mask"]
pub const IRQ_VBLANK: IRQ_MASKS = 1;
#[doc = "< horizontal blank interrupt mask"]
pub const IRQ_HBLANK: IRQ_MASKS = 2;
#[doc = "< vcount match interrupt mask"]
pub const IRQ_VCOUNT: IRQ_MASKS = 4;
#[doc = "< timer 0 interrupt mask"]
pub const IRQ_TIMER0: IRQ_MASKS = 8;
#[doc = "< timer 1 interrupt mask"]
pub const IRQ_TIMER1: IRQ_MASKS = 16;
#[doc = "< timer 2 interrupt mask"]
pub const IRQ_TIMER2: IRQ_MASKS = 32;
#[doc = "< timer 3 interrupt mask"]
pub const IRQ_TIMER3: IRQ_MASKS = 64;
#[doc = "< serial interrupt mask"]
pub const IRQ_NETWORK: IRQ_MASKS = 128;
#[doc = "< DMA 0 interrupt mask"]
pub const IRQ_DMA0: IRQ_MASKS = 256;
#[doc = "< DMA 1 interrupt mask"]
pub const IRQ_DMA1: IRQ_MASKS = 512;
#[doc = "< DMA 2 interrupt mask"]
pub const IRQ_DMA2: IRQ_MASKS = 1024;
#[doc = "< DMA 3 interrupt mask"]
pub const IRQ_DMA3: IRQ_MASKS = 2048;
#[doc = "< Keypad interrupt mask"]
pub const IRQ_KEYS: IRQ_MASKS = 4096;
#[doc = "< GBA cartridge interrupt mask"]
pub const IRQ_CART: IRQ_MASKS = 8192;
#[doc = "< IPC sync interrupt mask"]
pub const IRQ_IPC_SYNC: IRQ_MASKS = 65536;
#[doc = "< Send FIFO empty interrupt mask"]
pub const IRQ_FIFO_EMPTY: IRQ_MASKS = 131072;
#[doc = "< Receive FIFO not empty interrupt mask"]
pub const IRQ_FIFO_NOT_EMPTY: IRQ_MASKS = 262144;
#[doc = "< interrupt mask DS Card Slot"]
pub const IRQ_CARD: IRQ_MASKS = 524288;
#[doc = "< interrupt mask"]
pub const IRQ_CARD_LINE: IRQ_MASKS = 1048576;
#[doc = "< geometry FIFO interrupt mask"]
pub const IRQ_GEOMETRY_FIFO: IRQ_MASKS = 2097152;
#[doc = "< interrupt mask DS hinge"]
pub const IRQ_LID: IRQ_MASKS = 4194304;
#[doc = "< SPI interrupt mask"]
pub const IRQ_SPI: IRQ_MASKS = 8388608;
#[doc = "< WIFI interrupt mask (ARM7)"]
pub const IRQ_WIFI: IRQ_MASKS = 16777216;
#[doc = "< 'mask' for all interrupt"]
pub const IRQ_ALL: IRQ_MASKS = -1;
#[doc = "! values allowed for REG_IE and REG_IF"]
pub type IRQ_MASKS = i32;
pub use self::IRQ_MASKS as IRQ_MASK;
#[doc = "< I2C interrupt mask (DSi ARM7)"]
pub const IRQ_I2C: IRQ_MASKSAUX = 64;
#[doc = "< Sdmmc interrupt mask (DSi ARM7)"]
pub const IRQ_SDMMC: IRQ_MASKSAUX = 256;
#[doc = "! values allowed for REG_AUXIE and REG_AUXIF"]
pub type IRQ_MASKSAUX = u32;
#[doc = "< Disable all interrupts."]
pub const IME_DISABLE: IME_VALUE = 0;
#[doc = "< Enable all interrupts not masked out in REG_IE"]
pub const IME_ENABLE: IME_VALUE = 1;
#[doc = "! values allowed for REG_IME"]
pub type IME_VALUE = u32;
extern "C" {
    pub static mut __irq_vector: [VoidFn; 0usize];
}
extern "C" {
    pub static mut __irq_flags: [vuint32; 0usize];
}
extern "C" {
    pub static mut __irq_flagsaux: [vuint32; 0usize];
}
#[repr(C)]
pub struct IntTable {
    pub handler: IntFn,
    pub mask: u32,
}
#[test]
fn bindgen_test_layout_IntTable() {
    assert_eq!(
        ::core::mem::size_of::<IntTable>(),
        16usize,
        concat!("Size of: ", stringify!(IntTable))
    );
    assert_eq!(
        ::core::mem::align_of::<IntTable>(),
        8usize,
        concat!("Alignment of ", stringify!(IntTable))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IntTable>())).handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IntTable),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IntTable>())).mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IntTable),
            "::",
            stringify!(mask)
        )
    );
}
extern "C" {
    #[doc = " \\fn irqInit()"]
    #[doc = "\\brief Initialise the libnds interrupt system."]
    #[doc = ""]
    #[doc = "This function is called internally (prior to main()) to set up irqs"]
    #[doc = "on the ARM9.  It must be called on the ARM7 prior to installing irq"]
    #[doc = "handlers."]
    pub fn irqInit();
}
extern "C" {
    #[doc = " \\fn irqSet(u32 irq, VoidFn handler)"]
    #[doc = "\\brief Add a handler for the given interrupt mask."]
    #[doc = ""]
    #[doc = "Specify the handler to use for the given interrupt. This only works with"]
    #[doc = "the default interrupt handler, do not mix the use of this routine with a"]
    #[doc = "user-installed IRQ handler."]
    #[doc = "\\param irq Mask associated with the interrupt."]
    #[doc = "\\param handler Address of the function to use as an interrupt service routine"]
    #[doc = "\\note"]
    #[doc = "When any handler specifies using IRQ_VBLANK or IRQ_HBLANK, DISP_SR"]
    #[doc = "is automatically updated to include the corresponding DISP_VBLANK_IRQ or DISP_HBLANK_IRQ."]
    #[doc = ""]
    #[doc = "\\warning Only one IRQ_MASK can be specified with this function."]
    pub fn irqSet(irq: u32, handler: VoidFn);
}
extern "C" {
    pub fn irqSetAUX(irq: u32, handler: VoidFn);
}
extern "C" {
    #[doc = " \\fn irqClear(u32 irq)"]
    #[doc = "\\brief remove the handler associated with the interrupt mask irq."]
    #[doc = "\\param irq Mask associated with the interrupt."]
    pub fn irqClear(irq: u32);
}
extern "C" {
    pub fn irqClearAUX(irq: u32);
}
extern "C" {
    #[doc = " \\fn irqInitHandler(VoidFn handler)"]
    #[doc = "\\brief Install a user interrupt dispatcher."]
    #[doc = ""]
    #[doc = "This function installs the main interrupt function, all interrupts are serviced through this routine. For most"]
    #[doc = "purposes the libnds interrupt dispacther should be used in preference to user code unless you know *exactly* what you're doing."]
    #[doc = ""]
    #[doc = "\\param handler Address of the function to use as an interrupt dispatcher"]
    #[doc = "\\note the function *must* be ARM code"]
    pub fn irqInitHandler(handler: VoidFn);
}
extern "C" {
    #[doc = " \\fn irqEnable(u32 irq)"]
    #[doc = "\\brief Allow the given interrupt to occur."]
    #[doc = "\\param irq The set of interrupt masks to enable."]
    #[doc = "\\note Specify multiple interrupts to enable by ORing several IRQ_MASKS."]
    pub fn irqEnable(irq: u32);
}
extern "C" {
    pub fn irqEnableAUX(irq: u32);
}
extern "C" {
    #[doc = " \\fn irqDisable(u32 irq)"]
    #[doc = "\\brief Prevent the given interrupt from occuring."]
    #[doc = "\\param irq The set of interrupt masks to disable."]
    #[doc = "\\note Specify multiple interrupts to disable by ORing several IRQ_MASKS."]
    pub fn irqDisable(irq: u32);
}
extern "C" {
    pub fn irqDisableAUX(irq: u32);
}
extern "C" {
    #[doc = " \\fn swiIntrWait(u32 waitForSet, uint32 flags)"]
    #[doc = ""]
    #[doc = "\\brief wait for interrupt(s) to occur"]
    #[doc = ""]
    #[doc = "\\param waitForSet"]
    #[doc = "0: Return if the interrupt has already occured"]
    #[doc = "1: Wait until the interrupt has been set since the call"]
    #[doc = "\\param flags"]
    #[doc = "interrupt mask to wait for"]
    pub fn swiIntrWait(waitForSet: u32, flags: uint32);
}
extern "C" {
    #[doc = " \\fn  swiWaitForVBlank()"]
    #[doc = "\\brief Wait for vblank interrupt"]
    #[doc = ""]
    #[doc = "Waits for a vertical blank interrupt"]
    #[doc = ""]
    #[doc = "\\note Identical to calling swiIntrWait(1, 1)"]
    pub fn swiWaitForVBlank();
}
extern "C" {
    #[doc = " \\fn  VoidFn setPowerButtonCB(VoidFn CB);"]
    #[doc = "\\brief set callback for DSi Powerbutton press"]
    #[doc = ""]
    #[doc = "\\param CB"]
    #[doc = "function to call when power button pressed"]
    #[doc = "\\return"]
    #[doc = "the previously set callback"]
    pub fn setPowerButtonCB(CB: VoidFn) -> VoidFn;
}
pub const IPC_SYNC_IRQ_ENABLE: IPC_SYNC_BITS = 16384;
pub const IPC_SYNC_IRQ_REQUEST: IPC_SYNC_BITS = 8192;
pub type IPC_SYNC_BITS = u32;
pub const IPC_FIFO_SEND_EMPTY: IPC_CONTROL_BITS = 1;
pub const IPC_FIFO_SEND_FULL: IPC_CONTROL_BITS = 2;
pub const IPC_FIFO_SEND_IRQ: IPC_CONTROL_BITS = 4;
pub const IPC_FIFO_SEND_CLEAR: IPC_CONTROL_BITS = 8;
pub const IPC_FIFO_RECV_EMPTY: IPC_CONTROL_BITS = 256;
pub const IPC_FIFO_RECV_FULL: IPC_CONTROL_BITS = 512;
pub const IPC_FIFO_RECV_IRQ: IPC_CONTROL_BITS = 1024;
pub const IPC_FIFO_ERROR: IPC_CONTROL_BITS = 16384;
pub const IPC_FIFO_ENABLE: IPC_CONTROL_BITS = 32768;
pub type IPC_CONTROL_BITS = u32;
#[doc = "\\brief the GBA file header format."]
#[doc = "See gbatek for more info."]
#[repr(C, packed)]
pub struct sGBAHeader {
    #[doc = "!< 32 bits arm opcode to jump to executable code."]
    pub entryPoint: u32,
    #[doc = "!< nintendo logo needed for booting the game."]
    pub logo: [u8; 156usize],
    #[doc = "!< 12 characters for the game title."]
    pub title: [::std::os::raw::c_char; 12usize],
    #[doc = "!< 4 characters for the game code. first character is usally A or B, next 2 characters is a short title"]
    #[doc = "!< and last character is for destination/language."]
    pub gamecode: [::std::os::raw::c_char; 4usize],
    #[doc = "!< identifies the (commercial) developer."]
    pub makercode: u16,
    #[doc = "!< fixed value that is always 96h."]
    pub is96h: u8,
    #[doc = "!< identifies the required hardware."]
    pub unitcode: u8,
    #[doc = "!< used by nintedo's hardware debuggers. normally 0."]
    pub devicecode: u8,
    pub unused: [u8; 7usize],
    #[doc = "!< the version of the game."]
    pub version: u8,
    #[doc = "!< complement checksum of the gba header."]
    pub complement: u8,
    #[doc = "!< a 16 bit checksum? (gbatek says its unused/reserved)."]
    pub checksum: u16,
}
#[test]
fn bindgen_test_layout_sGBAHeader() {
    assert_eq!(
        ::core::mem::size_of::<sGBAHeader>(),
        192usize,
        concat!("Size of: ", stringify!(sGBAHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<sGBAHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(sGBAHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sGBAHeader>())).entryPoint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sGBAHeader),
            "::",
            stringify!(entryPoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sGBAHeader>())).logo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sGBAHeader),
            "::",
            stringify!(logo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sGBAHeader>())).title as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sGBAHeader),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sGBAHeader>())).gamecode as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(sGBAHeader),
            "::",
            stringify!(gamecode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sGBAHeader>())).makercode as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sGBAHeader),
            "::",
            stringify!(makercode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sGBAHeader>())).is96h as *const _ as usize },
        178usize,
        concat!(
            "Offset of field: ",
            stringify!(sGBAHeader),
            "::",
            stringify!(is96h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sGBAHeader>())).unitcode as *const _ as usize },
        179usize,
        concat!(
            "Offset of field: ",
            stringify!(sGBAHeader),
            "::",
            stringify!(unitcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sGBAHeader>())).devicecode as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(sGBAHeader),
            "::",
            stringify!(devicecode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sGBAHeader>())).unused as *const _ as usize },
        181usize,
        concat!(
            "Offset of field: ",
            stringify!(sGBAHeader),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sGBAHeader>())).version as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(sGBAHeader),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sGBAHeader>())).complement as *const _ as usize },
        189usize,
        concat!(
            "Offset of field: ",
            stringify!(sGBAHeader),
            "::",
            stringify!(complement)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sGBAHeader>())).checksum as *const _ as usize },
        190usize,
        concat!(
            "Offset of field: ",
            stringify!(sGBAHeader),
            "::",
            stringify!(checksum)
        )
    );
}
pub type tGBAHeader = sGBAHeader;
#[doc = "\\brief the NDS file header format"]
#[doc = "See gbatek for more info."]
#[repr(C, packed)]
pub struct sNDSHeader {
    #[doc = "!< 12 characters for the game title."]
    pub gameTitle: [::std::os::raw::c_char; 12usize],
    #[doc = "!< 4 characters for the game code."]
    pub gameCode: [::std::os::raw::c_char; 4usize],
    #[doc = "!< identifies the (commercial) developer."]
    pub makercode: [::std::os::raw::c_char; 2usize],
    #[doc = "!< identifies the required hardware."]
    pub unitCode: u8,
    #[doc = "!< type of device in the game card"]
    pub deviceType: u8,
    #[doc = "!< capacity of the device (1 << n Mbit)"]
    pub deviceSize: u8,
    pub reserved1: [u8; 9usize],
    #[doc = "!< version of the ROM."]
    pub romversion: u8,
    #[doc = "!< bit 2: auto-boot flag."]
    pub flags: u8,
    #[doc = "!< offset of the arm9 binary in the nds file."]
    pub arm9romOffset: u32,
    #[doc = "!< adress that should be executed after the binary has been copied."]
    pub arm9executeAddress: *mut ::core::ffi::c_void,
    #[doc = "!< destination address to where the arm9 binary should be copied."]
    pub arm9destination: *mut ::core::ffi::c_void,
    #[doc = "!< size of the arm9 binary."]
    pub arm9binarySize: u32,
    #[doc = "!< offset of the arm7 binary in the nds file."]
    pub arm7romOffset: u32,
    #[doc = "!< adress that should be executed after the binary has been copied."]
    pub arm7executeAddress: *mut ::core::ffi::c_void,
    #[doc = "!< destination address to where the arm7 binary should be copied."]
    pub arm7destination: *mut ::core::ffi::c_void,
    #[doc = "!< size of the arm7 binary."]
    pub arm7binarySize: u32,
    #[doc = "!< File Name Table (FNT) offset."]
    pub filenameOffset: u32,
    #[doc = "!< File Name Table (FNT) size."]
    pub filenameSize: u32,
    #[doc = "!< File Allocation Table (FAT) offset."]
    pub fatOffset: u32,
    #[doc = "!< File Allocation Table (FAT) size."]
    pub fatSize: u32,
    #[doc = "!< File arm9 overlay offset."]
    pub arm9overlaySource: u32,
    #[doc = "!< File arm9 overlay size."]
    pub arm9overlaySize: u32,
    #[doc = "!< File arm7 overlay offset."]
    pub arm7overlaySource: u32,
    #[doc = "!< File arm7 overlay size."]
    pub arm7overlaySize: u32,
    #[doc = "!< Port 40001A4h setting for normal commands (used in modes 1 and 3)"]
    pub cardControl13: u32,
    #[doc = "!< Port 40001A4h setting for KEY1 commands (used in mode 2)"]
    pub cardControlBF: u32,
    #[doc = "!< offset to the banner with icon and titles etc."]
    pub bannerOffset: u32,
    #[doc = "!< Secure Area Checksum, CRC-16."]
    pub secureCRC16: u16,
    #[doc = "!< Secure Area Loading Timeout."]
    pub readTimeout: u16,
    #[doc = "!< ARM9 Auto Load List RAM Address (?)"]
    pub unknownRAM1: u32,
    #[doc = "!< ARM7 Auto Load List RAM Address (?)"]
    pub unknownRAM2: u32,
    #[doc = "!< Secure Area Disable part 1."]
    pub bfPrime1: u32,
    #[doc = "!< Secure Area Disable part 2."]
    pub bfPrime2: u32,
    #[doc = "!< total size of the ROM."]
    pub romSize: u32,
    #[doc = "!< ROM header size."]
    pub headerSize: u32,
    pub zeros88: [u32; 14usize],
    #[doc = "!< Nintendo logo needed for booting the game."]
    pub gbaLogo: [u8; 156usize],
    #[doc = "!< Nintendo Logo Checksum, CRC-16."]
    pub logoCRC16: u16,
    #[doc = "!< header checksum, CRC-16."]
    pub headerCRC16: u16,
}
#[test]
fn bindgen_test_layout_sNDSHeader() {
    assert_eq!(
        ::core::mem::size_of::<sNDSHeader>(),
        368usize,
        concat!("Size of: ", stringify!(sNDSHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<sNDSHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(sNDSHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).gameTitle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(gameTitle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).gameCode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(gameCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).makercode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(makercode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).unitCode as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(unitCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).deviceType as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(deviceType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).deviceSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(deviceSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).reserved1 as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).romversion as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(romversion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).flags as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).arm9romOffset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(arm9romOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).arm9executeAddress as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(arm9executeAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).arm9destination as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(arm9destination)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).arm9binarySize as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(arm9binarySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).arm7romOffset as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(arm7romOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).arm7executeAddress as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(arm7executeAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).arm7destination as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(arm7destination)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).arm7binarySize as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(arm7binarySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).filenameOffset as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(filenameOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).filenameSize as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(filenameSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).fatOffset as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(fatOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).fatSize as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(fatSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).arm9overlaySource as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(arm9overlaySource)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).arm9overlaySize as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(arm9overlaySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).arm7overlaySource as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(arm7overlaySource)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).arm7overlaySize as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(arm7overlaySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).cardControl13 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(cardControl13)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).cardControlBF as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(cardControlBF)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).bannerOffset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(bannerOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).secureCRC16 as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(secureCRC16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).readTimeout as *const _ as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(readTimeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).unknownRAM1 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(unknownRAM1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).unknownRAM2 as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(unknownRAM2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).bfPrime1 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(bfPrime1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).bfPrime2 as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(bfPrime2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).romSize as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(romSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).headerSize as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(headerSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).zeros88 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(zeros88)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).gbaLogo as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(gbaLogo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).logoCRC16 as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(logoCRC16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSHeader>())).headerCRC16 as *const _ as usize },
        366usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSHeader),
            "::",
            stringify!(headerCRC16)
        )
    );
}
pub type tNDSHeader = sNDSHeader;
#[repr(C, packed)]
pub struct __DSiHeader {
    pub ndshdr: tNDSHeader,
    #[doc = "!< debug ROM offset."]
    pub debugRomSource: u32,
    #[doc = "!< debug size."]
    pub debugRomSize: u32,
    #[doc = "!< debug RAM destination."]
    pub debugRomDestination: u32,
    pub offset_0x16C: u32,
    pub zero: [u8; 16usize],
    pub global_mbk_setting: [[u8; 4usize]; 5usize],
    pub arm9_mbk_setting: [u32; 3usize],
    pub arm7_mbk_setting: [u32; 3usize],
    pub mbk9_wramcnt_setting: u32,
    pub region_flags: u32,
    pub access_control: u32,
    pub scfg_ext_mask: u32,
    pub offset_0x1BC: [u8; 3usize],
    pub appflags: u8,
    pub arm9iromOffset: *mut ::core::ffi::c_void,
    pub offset_0x1C4: u32,
    pub arm9idestination: *mut ::core::ffi::c_void,
    pub arm9ibinarySize: u32,
    pub arm7iromOffset: *mut ::core::ffi::c_void,
    pub offset_0x1D4: u32,
    pub arm7idestination: *mut ::core::ffi::c_void,
    pub arm7ibinarySize: u32,
    pub digest_ntr_start: u32,
    pub digest_ntr_size: u32,
    pub digest_twl_start: u32,
    pub digest_twl_size: u32,
    pub sector_hashtable_start: u32,
    pub sector_hashtable_size: u32,
    pub block_hashtable_start: u32,
    pub block_hashtable_size: u32,
    pub digest_sector_size: u32,
    pub digest_block_sectorcount: u32,
    pub banner_size: u32,
    pub offset_0x20C: u32,
    pub total_rom_size: u32,
    pub offset_0x214: u32,
    pub offset_0x218: u32,
    pub offset_0x21C: u32,
    pub modcrypt1_start: u32,
    pub modcrypt1_size: u32,
    pub modcrypt2_start: u32,
    pub modcrypt2_size: u32,
    pub tid_low: u32,
    pub tid_high: u32,
    pub public_sav_size: u32,
    pub private_sav_size: u32,
    pub reserved3: [u8; 176usize],
    pub age_ratings: [u8; 16usize],
    pub hmac_arm9: [u8; 20usize],
    pub hmac_arm7: [u8; 20usize],
    pub hmac_digest_master: [u8; 20usize],
    pub hmac_icon_title: [u8; 20usize],
    pub hmac_arm9i: [u8; 20usize],
    pub hmac_arm7i: [u8; 20usize],
    pub reserved4: [u8; 40usize],
    pub hmac_arm9_no_secure: [u8; 20usize],
    pub reserved5: [u8; 2636usize],
    pub debug_args: [u8; 384usize],
    pub rsa_signature: [u8; 128usize],
}
#[test]
fn bindgen_test_layout___DSiHeader() {
    assert_eq!(
        ::core::mem::size_of::<__DSiHeader>(),
        4128usize,
        concat!("Size of: ", stringify!(__DSiHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<__DSiHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(__DSiHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).ndshdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(ndshdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).debugRomSource as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(debugRomSource)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).debugRomSize as *const _ as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(debugRomSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DSiHeader>())).debugRomDestination as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(debugRomDestination)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).offset_0x16C as *const _ as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(offset_0x16C)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).zero as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(zero)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).global_mbk_setting as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(global_mbk_setting)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).arm9_mbk_setting as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(arm9_mbk_setting)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).arm7_mbk_setting as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(arm7_mbk_setting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DSiHeader>())).mbk9_wramcnt_setting as *const _ as usize
        },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(mbk9_wramcnt_setting)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).region_flags as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(region_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).access_control as *const _ as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(access_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).scfg_ext_mask as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(scfg_ext_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).offset_0x1BC as *const _ as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(offset_0x1BC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).appflags as *const _ as usize },
        463usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(appflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).arm9iromOffset as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(arm9iromOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).offset_0x1C4 as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(offset_0x1C4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).arm9idestination as *const _ as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(arm9idestination)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).arm9ibinarySize as *const _ as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(arm9ibinarySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).arm7iromOffset as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(arm7iromOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).offset_0x1D4 as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(offset_0x1D4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).arm7idestination as *const _ as usize },
        500usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(arm7idestination)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).arm7ibinarySize as *const _ as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(arm7ibinarySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).digest_ntr_start as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(digest_ntr_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).digest_ntr_size as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(digest_ntr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).digest_twl_start as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(digest_twl_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).digest_twl_size as *const _ as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(digest_twl_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DSiHeader>())).sector_hashtable_start as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(sector_hashtable_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DSiHeader>())).sector_hashtable_size as *const _ as usize
        },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(sector_hashtable_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DSiHeader>())).block_hashtable_start as *const _ as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(block_hashtable_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DSiHeader>())).block_hashtable_size as *const _ as usize
        },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(block_hashtable_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).digest_sector_size as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(digest_sector_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DSiHeader>())).digest_block_sectorcount as *const _ as usize
        },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(digest_block_sectorcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).banner_size as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(banner_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).offset_0x20C as *const _ as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(offset_0x20C)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).total_rom_size as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(total_rom_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).offset_0x214 as *const _ as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(offset_0x214)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).offset_0x218 as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(offset_0x218)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).offset_0x21C as *const _ as usize },
        572usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(offset_0x21C)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).modcrypt1_start as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(modcrypt1_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).modcrypt1_size as *const _ as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(modcrypt1_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).modcrypt2_start as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(modcrypt2_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).modcrypt2_size as *const _ as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(modcrypt2_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).tid_low as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(tid_low)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).tid_high as *const _ as usize },
        596usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(tid_high)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).public_sav_size as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(public_sav_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).private_sav_size as *const _ as usize },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(private_sav_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).reserved3 as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).age_ratings as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(age_ratings)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).hmac_arm9 as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(hmac_arm9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).hmac_arm7 as *const _ as usize },
        820usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(hmac_arm7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).hmac_digest_master as *const _ as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(hmac_digest_master)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).hmac_icon_title as *const _ as usize },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(hmac_icon_title)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).hmac_arm9i as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(hmac_arm9i)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).hmac_arm7i as *const _ as usize },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(hmac_arm7i)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).reserved4 as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__DSiHeader>())).hmac_arm9_no_secure as *const _ as usize
        },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(hmac_arm9_no_secure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).reserved5 as *const _ as usize },
        980usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).debug_args as *const _ as usize },
        3616usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(debug_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__DSiHeader>())).rsa_signature as *const _ as usize },
        4000usize,
        concat!(
            "Offset of field: ",
            stringify!(__DSiHeader),
            "::",
            stringify!(rsa_signature)
        )
    );
}
pub type tDSiHeader = __DSiHeader;
#[doc = "\\brief the NDS banner format."]
#[doc = "See gbatek for more information."]
#[repr(C, packed)]
pub struct sNDSBanner {
    #[doc = "!< version of the banner."]
    pub version: u16,
    #[doc = "!< 16 bit crc/checksum of the banner."]
    pub crc: u16,
    pub reserved: [u8; 28usize],
    #[doc = "!< 32*32 icon of the game with 4 bit per pixel."]
    pub icon: [u8; 512usize],
    #[doc = "!< the pallete of the icon."]
    pub palette: [u16; 16usize],
    #[doc = "!< title of the game in 6 different languages."]
    pub titles: [[u16; 128usize]; 6usize],
}
#[test]
fn bindgen_test_layout_sNDSBanner() {
    assert_eq!(
        ::core::mem::size_of::<sNDSBanner>(),
        2112usize,
        concat!("Size of: ", stringify!(sNDSBanner))
    );
    assert_eq!(
        ::core::mem::align_of::<sNDSBanner>(),
        1usize,
        concat!("Alignment of ", stringify!(sNDSBanner))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSBanner>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSBanner),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSBanner>())).crc as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSBanner),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSBanner>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSBanner),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSBanner>())).icon as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSBanner),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSBanner>())).palette as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSBanner),
            "::",
            stringify!(palette)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sNDSBanner>())).titles as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(sNDSBanner),
            "::",
            stringify!(titles)
        )
    );
}
pub type tNDSBanner = sNDSBanner;
#[doc = "!<\tThe display currently in a vertical blank."]
pub const DISP_IN_VBLANK: DISP_BITS = 1;
#[doc = "!<\tThe display currently in a horizontal blank."]
pub const DISP_IN_HBLANK: DISP_BITS = 2;
#[doc = "!<\tCurrent scanline and %DISP_Y match."]
pub const DISP_YTRIGGERED: DISP_BITS = 4;
#[doc = "!<\tInterrupt on vertical blank."]
pub const DISP_VBLANK_IRQ: DISP_BITS = 8;
#[doc = "!<\tInterrupt on horizontal blank."]
pub const DISP_HBLANK_IRQ: DISP_BITS = 16;
#[doc = "!<\tInterrupt when current scanline and %DISP_Y match."]
pub const DISP_YTRIGGER_IRQ: DISP_BITS = 32;
#[doc = "! LCD Status register bitdefines"]
pub type DISP_BITS = u32;
#[doc = "!< Power the sound hardware (needed to hear stuff in GBA mode too)."]
pub const PM_SOUND_AMP: PM_Bits = 1;
#[doc = "!< Mute the main speakers, headphone output will still work."]
pub const PM_SOUND_MUTE: PM_Bits = 2;
#[doc = "!< Enable the bottom backlight if set."]
pub const PM_BACKLIGHT_BOTTOM: PM_Bits = 4;
#[doc = "!< Enable the top backlight if set."]
pub const PM_BACKLIGHT_TOP: PM_Bits = 8;
#[doc = "!< Turn the power *off* if set."]
pub const PM_SYSTEM_PWR: PM_Bits = 64;
#[doc = "!<\tControls the power for both LCD screens."]
pub const POWER_LCD: PM_Bits = 65537;
#[doc = "!<\tControls the power for the main 2D core."]
pub const POWER_2D_A: PM_Bits = 65538;
#[doc = "!<\tControls the power for the 3D matrix."]
pub const POWER_MATRIX: PM_Bits = 65540;
#[doc = "!<\tControls the power for the main 3D core."]
pub const POWER_3D_CORE: PM_Bits = 65544;
#[doc = "!<\tControls the power for the sub 2D core."]
pub const POWER_2D_B: PM_Bits = 66048;
#[doc = "!<\tControls which screen should use the main core."]
pub const POWER_SWAP_LCDS: PM_Bits = 98304;
#[doc = "!< power just 2D hardware."]
pub const POWER_ALL_2D: PM_Bits = 66051;
#[doc = "!< power everything."]
pub const POWER_ALL: PM_Bits = 66063;
#[doc = "! Power Management control bits"]
pub type PM_Bits = u32;
extern "C" {
    #[doc = "\t\\brief Causes the nds to go to sleep."]
    #[doc = "The nds will be reawakened when the lid is opened."]
    #[doc = ""]
    #[doc = "\\note By default, this is automatically called when closing the lid."]
    pub fn systemSleep();
}
extern "C" {
    #[doc = "\tSet the LED blink mode"]
    #[doc = "\\param bm What to power on."]
    pub fn ledBlink(bm: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "!\tTurns on specified hardware."]
    #[doc = "*!\tMay be called from arm7 or arm9 (arm9 power bits will be ignored by arm7, arm7 power bits"]
    #[doc = "will be passed to the arm7 from the arm9)."]
    #[doc = ""]
    #[doc = "\\param bits What to power on."]
    #[doc = "*/"]
    pub fn powerOn(bits: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "!\tTurns off specified hardware."]
    #[doc = "*!\tMay be called from arm7 or arm9 (arm9 power bits will be ignored by arm7, arm7 power bits"]
    #[doc = "will be passed to the arm7 from the arm9)."]
    #[doc = ""]
    #[doc = "\\param bits What to power on."]
    #[doc = "*/"]
    pub fn powerOff(bits: ::std::os::raw::c_int);
}
extern "C" {
    pub fn systemMsgHandler(bytes: ::std::os::raw::c_int, user_data: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn systemValueHandler(value: u32, data: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn readFirmware(address: u32, buffer: *mut ::core::ffi::c_void, length: u32);
}
extern "C" {
    pub fn writeFirmware(
        address: u32,
        buffer: *mut ::core::ffi::c_void,
        length: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "! gets the DS Battery level"]
    pub fn getBatteryLevel() -> u32;
}
extern "C" {
    #[doc = "!\tSet the arm9 vector base"]
    #[doc = "*!\tArm9 only"]
    #[doc = "\\param highVector high vector"]
    #[doc = "*/"]
    pub fn setVectorBase(highVector: ::std::os::raw::c_int);
}
#[doc = " \\brief A struct with all the CPU exeption vectors."]
#[doc = "each member contains an ARM instuction that will be executed when an exeption occured."]
#[doc = ""]
#[doc = "See gbatek for more information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysVectors_t {
    #[doc = "!< CPU reset."]
    pub reset: VoidFn,
    #[doc = "!< undefined instruction."]
    pub undefined: VoidFn,
    #[doc = "!< software interrupt."]
    pub swi: VoidFn,
    #[doc = "!< prefetch abort."]
    pub prefetch_abort: VoidFn,
    #[doc = "!< data abort."]
    pub data_abort: VoidFn,
    #[doc = "!< fast interrupt."]
    pub fiq: VoidFn,
}
#[test]
fn bindgen_test_layout_sysVectors_t() {
    assert_eq!(
        ::core::mem::size_of::<sysVectors_t>(),
        48usize,
        concat!("Size of: ", stringify!(sysVectors_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sysVectors_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sysVectors_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysVectors_t>())).reset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysVectors_t),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysVectors_t>())).undefined as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sysVectors_t),
            "::",
            stringify!(undefined)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysVectors_t>())).swi as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sysVectors_t),
            "::",
            stringify!(swi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysVectors_t>())).prefetch_abort as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sysVectors_t),
            "::",
            stringify!(prefetch_abort)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysVectors_t>())).data_abort as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sysVectors_t),
            "::",
            stringify!(data_abort)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysVectors_t>())).fiq as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sysVectors_t),
            "::",
            stringify!(fiq)
        )
    );
}
pub type sysVectors = sysVectors_t;
extern "C" {
    pub static mut SystemVectors: sysVectors;
}
extern "C" {
    pub fn setSDcallback(
        callback: ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    );
}
extern "C" {
    #[doc = "\\brief Sets the ARM9 clock speed, only possible in DSi mode"]
    #[doc = "\\param speed CPU speed (false = 67.03MHz, true = 134.06MHz)"]
    #[doc = "\\return The old CPU speed value"]
    pub fn setCpuClock(speed: bool) -> bool;
}
extern "C" {
    #[doc = "! returns current start of heap space"]
    pub fn getHeapStart() -> *mut u8;
}
extern "C" {
    #[doc = "! returns current end of heap space"]
    pub fn getHeapEnd() -> *mut u8;
}
extern "C" {
    #[doc = "! returns current heap limit"]
    pub fn getHeapLimit() -> *mut u8;
}
#[doc = "!< low backlight setting."]
pub const BACKLIGHT_LOW: BACKLIGHT_LEVELS = 0;
#[doc = "!< medium backlight setting."]
pub const BACKLIGHT_MED: BACKLIGHT_LEVELS = 1;
#[doc = "!< high backlight setting."]
pub const BACKLIGHT_HIGH: BACKLIGHT_LEVELS = 2;
#[doc = "!< max backlight setting."]
pub const BACKLIGHT_MAX: BACKLIGHT_LEVELS = 3;
#[doc = "\t\\brief Backlight level settings."]
#[doc = "Note, these are only available on DS Lite."]
pub type BACKLIGHT_LEVELS = u32;
#[doc = "\\brief User's DS settings."]
#[doc = "Defines the structure the DS firmware uses for transfer"]
#[doc = "of the user's settings to the booted program."]
#[doc = ""]
#[doc = "Theme/Color values:"]
#[doc = "- 0 = Gray"]
#[doc = "- 1 = Brown"]
#[doc = "- 2 = Red"]
#[doc = "- 3 = Pink"]
#[doc = "- 4 = Orange"]
#[doc = "- 5 = Yellow"]
#[doc = "- 6 = Yellow/Green-ish"]
#[doc = "- 7 = Green"]
#[doc = "- 8 = Dark Green"]
#[doc = "- 9 = Green/Blue-ish"]
#[doc = "- 10 = Light Blue"]
#[doc = "- 11 = Blue"]
#[doc = "- 12 = Dark Blue"]
#[doc = "- 13 = Dark Purple"]
#[doc = "- 14 = Purple"]
#[doc = "- 15 = Purple/Red-ish"]
#[doc = ""]
#[doc = "Language values:"]
#[doc = "- 0 = Japanese"]
#[doc = "- 1 = English"]
#[doc = "- 2 = French"]
#[doc = "- 3 = German"]
#[doc = "- 4 = Italian"]
#[doc = "- 5 = Spanish"]
#[doc = "- 6 = Chinese(?)"]
#[doc = "- 7 = Unknown/Reserved"]
#[repr(C, packed)]
pub struct tPERSONAL_DATA {
    pub RESERVED0: [u8; 2usize],
    #[doc = "!<\tThe user's theme color (0-15)."]
    pub theme: u8,
    #[doc = "!<\tThe user's birth month (1-12)."]
    pub birthMonth: u8,
    #[doc = "!<\tThe user's birth day (1-31)."]
    pub birthDay: u8,
    pub RESERVED1: [u8; 1usize],
    #[doc = "!<\tThe user's name in UTF-16 format."]
    pub name: [s16; 10usize],
    #[doc = "!<\tThe length of the user's name in characters."]
    pub nameLen: u16,
    #[doc = "!<\tThe user's message."]
    pub message: [s16; 26usize],
    #[doc = "!<\tThe length of the user's message in characters."]
    pub messageLen: u16,
    #[doc = "!<\tWhat hour the alarm clock is set to (0-23)."]
    pub alarmHour: u8,
    #[doc = "!<\tWhat minute the alarm clock is set to (0-59)."]
    pub alarmMinute: u8,
    pub RESERVED2: [u8; 4usize],
    #[doc = "!<\tTouchscreen calibration: first X touch"]
    pub calX1: u16,
    #[doc = "!<\tTouchscreen calibration: first Y touch"]
    pub calY1: u16,
    #[doc = "!<\tTouchscreen calibration: first X touch pixel"]
    pub calX1px: u8,
    #[doc = "!<\tTouchscreen calibration: first X touch pixel"]
    pub calY1px: u8,
    #[doc = "!<\tTouchscreen calibration: second X touch"]
    pub calX2: u16,
    #[doc = "!<\tTouchscreen calibration: second Y touch"]
    pub calY2: u16,
    #[doc = "!<\tTouchscreen calibration: second X touch pixel"]
    pub calX2px: u8,
    #[doc = "!<\tTouchscreen calibration: second Y touch pixel"]
    pub calY2px: u8,
    pub __bindgen_anon_1: tPERSONAL_DATA__bindgen_ty_1,
    pub RESERVED3: u16,
    #[doc = "!<\tReal Time Clock offset."]
    pub rtcOffset: u32,
    pub RESERVED4: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tPERSONAL_DATA__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_tPERSONAL_DATA__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<tPERSONAL_DATA__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(tPERSONAL_DATA__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<tPERSONAL_DATA__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(tPERSONAL_DATA__bindgen_ty_1))
    );
}
impl tPERSONAL_DATA__bindgen_ty_1 {
    #[inline]
    pub fn language(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_language(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn gbaScreen(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gbaScreen(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn defaultBrightness(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_defaultBrightness(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn autoMode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoMode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESERVED5(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RESERVED5(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn settingsLost(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_settingsLost(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESERVED6(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_RESERVED6(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        language: ::std::os::raw::c_uint,
        gbaScreen: ::std::os::raw::c_uint,
        defaultBrightness: ::std::os::raw::c_uint,
        autoMode: ::std::os::raw::c_uint,
        RESERVED5: ::std::os::raw::c_uint,
        settingsLost: ::std::os::raw::c_uint,
        RESERVED6: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let language: u32 = unsafe { ::core::mem::transmute(language) };
            language as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let gbaScreen: u32 = unsafe { ::core::mem::transmute(gbaScreen) };
            gbaScreen as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let defaultBrightness: u32 = unsafe { ::core::mem::transmute(defaultBrightness) };
            defaultBrightness as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let autoMode: u32 = unsafe { ::core::mem::transmute(autoMode) };
            autoMode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let RESERVED5: u32 = unsafe { ::core::mem::transmute(RESERVED5) };
            RESERVED5 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let settingsLost: u32 = unsafe { ::core::mem::transmute(settingsLost) };
            settingsLost as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let RESERVED6: u32 = unsafe { ::core::mem::transmute(RESERVED6) };
            RESERVED6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_tPERSONAL_DATA() {
    assert_eq!(
        ::core::mem::size_of::<tPERSONAL_DATA>(),
        112usize,
        concat!("Size of: ", stringify!(tPERSONAL_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<tPERSONAL_DATA>(),
        1usize,
        concat!("Alignment of ", stringify!(tPERSONAL_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).RESERVED0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).theme as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(theme)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).birthMonth as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(birthMonth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).birthDay as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(birthDay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).RESERVED1 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).name as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).nameLen as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(nameLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).message as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).messageLen as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(messageLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).alarmHour as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(alarmHour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).alarmMinute as *const _ as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(alarmMinute)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).RESERVED2 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).calX1 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(calX1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).calY1 as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(calY1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).calX1px as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(calX1px)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).calY1px as *const _ as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(calY1px)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).calX2 as *const _ as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(calX2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).calY2 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(calY2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).calX2px as *const _ as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(calX2px)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).calY2px as *const _ as usize },
        99usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(calY2px)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).RESERVED3 as *const _ as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).rtcOffset as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(rtcOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tPERSONAL_DATA>())).RESERVED4 as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(tPERSONAL_DATA),
            "::",
            stringify!(RESERVED4)
        )
    );
}
pub type PERSONAL_DATA = tPERSONAL_DATA;
#[doc = "! struct containing time and day of the real time clock."]
#[repr(C)]
pub struct RTCtime {
    #[doc = "!< add 2000 to get 4 digit year"]
    pub year: u8,
    #[doc = "!< 1 to 12"]
    pub month: u8,
    #[doc = "!< 1 to (days in month)"]
    pub day: u8,
    #[doc = "!< day of week"]
    pub weekday: u8,
    #[doc = "!< 0 to 11 for AM, 52 to 63 for PM"]
    pub hours: u8,
    #[doc = "!< 0 to 59"]
    pub minutes: u8,
    #[doc = "!< 0 to 59"]
    pub seconds: u8,
}
#[test]
fn bindgen_test_layout_RTCtime() {
    assert_eq!(
        ::core::mem::size_of::<RTCtime>(),
        7usize,
        concat!("Size of: ", stringify!(RTCtime))
    );
    assert_eq!(
        ::core::mem::align_of::<RTCtime>(),
        1usize,
        concat!("Alignment of ", stringify!(RTCtime))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTCtime>())).year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTCtime),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTCtime>())).month as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(RTCtime),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTCtime>())).day as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RTCtime),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTCtime>())).weekday as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(RTCtime),
            "::",
            stringify!(weekday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTCtime>())).hours as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RTCtime),
            "::",
            stringify!(hours)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTCtime>())).minutes as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(RTCtime),
            "::",
            stringify!(minutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTCtime>())).seconds as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(RTCtime),
            "::",
            stringify!(seconds)
        )
    );
}
#[repr(C)]
pub struct __argv {
    pub argvMagic: ::std::os::raw::c_int,
    pub commandLine: *mut ::std::os::raw::c_char,
    pub length: ::std::os::raw::c_int,
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
    pub dummy: ::std::os::raw::c_int,
    pub host: u32,
}
#[test]
fn bindgen_test_layout___argv() {
    assert_eq!(
        ::core::mem::size_of::<__argv>(),
        40usize,
        concat!("Size of: ", stringify!(__argv))
    );
    assert_eq!(
        ::core::mem::align_of::<__argv>(),
        8usize,
        concat!("Alignment of ", stringify!(__argv))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__argv>())).argvMagic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__argv),
            "::",
            stringify!(argvMagic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__argv>())).commandLine as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__argv),
            "::",
            stringify!(commandLine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__argv>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__argv),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__argv>())).argc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__argv),
            "::",
            stringify!(argc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__argv>())).argv as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__argv),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__argv>())).dummy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__argv),
            "::",
            stringify!(dummy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__argv>())).host as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__argv),
            "::",
            stringify!(host)
        )
    );
}
#[repr(C)]
pub struct __bootstub {
    pub bootsig: u64,
    pub arm9reboot: VoidFn,
    pub arm7reboot: VoidFn,
    pub bootsize: u32,
}
#[test]
fn bindgen_test_layout___bootstub() {
    assert_eq!(
        ::core::mem::size_of::<__bootstub>(),
        32usize,
        concat!("Size of: ", stringify!(__bootstub))
    );
    assert_eq!(
        ::core::mem::align_of::<__bootstub>(),
        8usize,
        concat!("Alignment of ", stringify!(__bootstub))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__bootstub>())).bootsig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bootstub),
            "::",
            stringify!(bootsig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__bootstub>())).arm9reboot as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__bootstub),
            "::",
            stringify!(arm9reboot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__bootstub>())).arm7reboot as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__bootstub),
            "::",
            stringify!(arm7reboot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__bootstub>())).bootsize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__bootstub),
            "::",
            stringify!(bootsize)
        )
    );
}
extern "C" {
    #[doc = "\\brief returns a cached mirror of an address."]
    #[doc = "\\param address an address."]
    #[doc = "\\return a pointer to the cached mirror of that address."]
    pub fn memCached(address: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = "\\brief returns an uncached mirror of an address."]
    #[doc = "\\param address an address."]
    #[doc = "\\return a pointer to the uncached mirror of that address."]
    pub fn memUncached(address: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn resetARM7(address: u32);
}
#[doc = "!< divides the timer clock by 1 (~33513.982 kHz)"]
pub const ClockDivider_1: ClockDivider = 0;
#[doc = "!< divides the timer clock by 64 (~523.657 kHz)"]
pub const ClockDivider_64: ClockDivider = 1;
#[doc = "!< divides the timer clock by 256 (~130.914 kHz)"]
pub const ClockDivider_256: ClockDivider = 2;
#[doc = "!< divides the timer clock by 1024 (~32.7284 kHz)"]
pub const ClockDivider_1024: ClockDivider = 3;
#[doc = "! allowable timer clock dividers."]
pub type ClockDivider = u32;
extern "C" {
    #[doc = "\t\\brief start a hardware timer."]
    #[doc = "Callback is tied directly to interrupt table and called directly, resulting in less latency than the attached timer."]
    #[doc = "\\param timer \tThe hardware timer to use (0 - 3)."]
    #[doc = "\\param divider \tThe timer channel clock divider (clock will tick at 33.513982 MHz / divider)"]
    #[doc = "\\param ticks\tThe number of ticks which must elapse before the timer overflows"]
    #[doc = "\\param callback The callback to be called when the timer expires (if null, no IRQ will be generated by the timer)"]
    pub fn timerStart(
        timer: ::std::os::raw::c_int,
        divider: ClockDivider,
        ticks: u16,
        callback: VoidFn,
    );
}
extern "C" {
    #[doc = "\t\\brief returns the ticks elapsed since the last call to timerElapsed()."]
    #[doc = "\\param timer The hardware timer to use (0 - 3)."]
    #[doc = "\\return The number of ticks which have elapsed since the last call to timerElapsed()."]
    pub fn timerElapsed(timer: ::std::os::raw::c_int) -> u16;
}
extern "C" {
    #[doc = "\t\\brief pauses the specified timer."]
    #[doc = "\\param timer The hardware timer to use (0 - 3)."]
    #[doc = "\\return The number of ticks which have elapsed since the last call to timerElapsed()."]
    pub fn timerPause(timer: ::std::os::raw::c_int) -> u16;
}
extern "C" {
    #[doc = "\t\\brief Stops the specified timer."]
    #[doc = "\\param timer The hardware timer to use (0 - 3)."]
    #[doc = "\\return The number of ticks which have elapsed since the last call to timerElapsed()."]
    pub fn timerStop(timer: ::std::os::raw::c_int) -> u16;
}
extern "C" {
    #[doc = "\t\\brief begins cpu Timing using two timers for 32bit resolution."]
    #[doc = "\\param timer The base hardware timer to use (0 - 2)."]
    pub fn cpuStartTiming(timer: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\t\\brief returns the number of ticks which have elapsed since cpuStartTiming."]
    #[doc = "\\return The number of ticks which have elapsed since cpuStartTiming."]
    pub fn cpuGetTiming() -> u32;
}
extern "C" {
    #[doc = "\t\\brief ends cpu Timing."]
    #[doc = "\\return The number of ticks which have elapsed since cpuStartTiming."]
    pub fn cpuEndTiming() -> u32;
}
#[doc = "< \\brief fifo channel reserved for power management."]
pub const FIFO_PM: FifoChannels = 0;
#[doc = "< \\brief fifo channel reserved for sound access."]
pub const FIFO_SOUND: FifoChannels = 1;
#[doc = "< \\brief fifo channel reserved for system functions."]
pub const FIFO_SYSTEM: FifoChannels = 2;
#[doc = "< \\brief fifo channel reserved for the maxmod library."]
pub const FIFO_MAXMOD: FifoChannels = 3;
#[doc = "< \\brief fifo channel reserved for the dswifi library."]
pub const FIFO_DSWIFI: FifoChannels = 4;
#[doc = "< \\brief fifo channel reserved for dsi sdmmc control."]
pub const FIFO_SDMMC: FifoChannels = 5;
#[doc = "< \\brief fifo channel reserved for firmware access."]
pub const FIFO_FIRMWARE: FifoChannels = 6;
#[doc = "< \\brief fifo channel reserved for future use."]
pub const FIFO_RSVD_01: FifoChannels = 7;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_01: FifoChannels = 8;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_02: FifoChannels = 9;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_03: FifoChannels = 10;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_04: FifoChannels = 11;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_05: FifoChannels = 12;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_06: FifoChannels = 13;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_07: FifoChannels = 14;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_08: FifoChannels = 15;
#[doc = "! Enum values for the different fifo channels."]
pub type FifoChannels = u32;
pub const SOUND_SET_PAN: FifoSoundCommand = 0;
pub const SOUND_SET_VOLUME: FifoSoundCommand = 1048576;
pub const SOUND_SET_FREQ: FifoSoundCommand = 2097152;
pub const SOUND_SET_WAVEDUTY: FifoSoundCommand = 3145728;
pub const SOUND_MASTER_ENABLE: FifoSoundCommand = 4194304;
pub const SOUND_MASTER_DISABLE: FifoSoundCommand = 5242880;
pub const SOUND_PAUSE: FifoSoundCommand = 6291456;
pub const SOUND_RESUME: FifoSoundCommand = 7340032;
pub const SOUND_KILL: FifoSoundCommand = 8388608;
pub const SOUND_SET_MASTER_VOL: FifoSoundCommand = 9437184;
pub const MIC_STOP: FifoSoundCommand = 10485760;
#[doc = "! Enum values for the fifo sound commands."]
pub type FifoSoundCommand = u32;
pub const SYS_REQ_TOUCH: FifoSystemCommands = 0;
pub const SYS_REQ_KEYS: FifoSystemCommands = 1;
pub const SYS_REQ_TIME: FifoSystemCommands = 2;
pub const SYS_SET_TIME: FifoSystemCommands = 3;
pub const SDMMC_INSERT: FifoSystemCommands = 4;
pub const SDMMC_REMOVE: FifoSystemCommands = 5;
#[doc = "! Enum values for the fifo system commands."]
pub type FifoSystemCommands = u32;
pub const SDMMC_HAVE_SD: FifoSdmmcCommands = 0;
pub const SDMMC_SD_START: FifoSdmmcCommands = 1;
pub const SDMMC_SD_IS_INSERTED: FifoSdmmcCommands = 2;
pub const SDMMC_SD_STOP: FifoSdmmcCommands = 3;
pub const SDMMC_NAND_START: FifoSdmmcCommands = 4;
pub const SDMMC_NAND_STOP: FifoSdmmcCommands = 5;
pub const SDMMC_NAND_SIZE: FifoSdmmcCommands = 6;
pub type FifoSdmmcCommands = u32;
pub const FW_READ: FifoFirmwareCommands = 0;
pub const FW_WRITE: FifoFirmwareCommands = 1;
pub type FifoFirmwareCommands = u32;
pub const PM_REQ_ON: FifoPMCommands = 65536;
pub const PM_REQ_OFF: FifoPMCommands = 131072;
pub const PM_REQ_LED: FifoPMCommands = 196608;
pub const PM_REQ_SLEEP: FifoPMCommands = 262144;
pub const PM_REQ_SLEEP_DISABLE: FifoPMCommands = 327680;
pub const PM_REQ_SLEEP_ENABLE: FifoPMCommands = 393216;
pub const PM_REQ_BATTERY: FifoPMCommands = 458752;
pub const PM_REQ_SLOT1_DISABLE: FifoPMCommands = 524288;
pub const PM_REQ_SLOT1_ENABLE: FifoPMCommands = 589824;
#[doc = "! Enum values for the fifo power management commands."]
pub type FifoPMCommands = u32;
pub const WIFI_ENABLE: FifoWifiCommands = 0;
pub const WIFI_DISABLE: FifoWifiCommands = 1;
pub const WIFI_SYNC: FifoWifiCommands = 2;
pub const WIFI_STARTUP: FifoWifiCommands = 3;
#[doc = "! Enum values for the fifo wifi commands."]
pub type FifoWifiCommands = u32;
#[doc = "< \\brief  Steady on"]
pub const PM_LED_ON: PM_LedBlinkMode = 0;
#[doc = "< \\brief Blinking, mostly off"]
pub const PM_LED_SLEEP: PM_LedBlinkMode = 1;
#[doc = "< \\brief Blinking, mostly on"]
pub const PM_LED_BLINK: PM_LedBlinkMode = 3;
#[doc = "! Power Management LED blink mode control bits."]
pub type PM_LedBlinkMode = u32;
#[doc = "\\brief fifo callback function pointer with the sent address and the callback's user data."]
#[doc = ""]
#[doc = "The handler is called when new data arrives."]
#[doc = ""]
#[doc = "\\note callback functions are called from interrupt level, but are well secured. not too much caution is necessary,"]
#[doc = "but don't call alloc, free or printf from within them, just to be safe."]
pub type FifoAddressHandlerFunc = ::core::option::Option<
    unsafe extern "C" fn(address: *mut ::core::ffi::c_void, userdata: *mut ::core::ffi::c_void),
>;
#[doc = "\\brief fifo callback function pointer with the sent value and the callback's user data."]
#[doc = ""]
#[doc = "The handler is called when new data arrives."]
#[doc = ""]
#[doc = "\\note callback functions are called from interrupt level, but are well secured. not too much caution is necessary,"]
#[doc = "but don't call alloc, free or printf from within them, just to be safe."]
pub type FifoValue32HandlerFunc =
    ::core::option::Option<unsafe extern "C" fn(value32: u32, userdata: *mut ::core::ffi::c_void)>;
#[doc = "\\brief fifo callback function pointer with the number of bytes sent and the callback's user data"]
#[doc = ""]
#[doc = "The handler is called when new data arrives."]
#[doc = "This callback must call fifoGetData to actually retrieve the data. If it doesn't, the data will be destroyed on return."]
#[doc = ""]
#[doc = "\\note callback functions are called from interrupt level, but are well secured. not too much caution is necessary,"]
#[doc = "but don't call alloc, free or printf from within them, just to be safe."]
pub type FifoDatamsgHandlerFunc = ::core::option::Option<
    unsafe extern "C" fn(num_bytes: ::std::os::raw::c_int, userdata: *mut ::core::ffi::c_void),
>;
extern "C" {
    #[doc = "\\brief Initializes the fifo system."]
    #[doc = ""]
    #[doc = "Attempts to sync with the other CPU, if it fails, fifo services won't be provided."]
    #[doc = ""]
    #[doc = "\\note call irqInit() before calling this function."]
    #[doc = ""]
    #[doc = "\\return true if syncing worked, false if something went wrong."]
    pub fn fifoInit() -> bool;
}
extern "C" {
    #[doc = "\\brief Send an address to an channel."]
    #[doc = ""]
    #[doc = "Transmits an address in the range 0x02000000-0x023FFFFF to the other CPU."]
    #[doc = ""]
    #[doc = "\\param channel channel number to send to."]
    #[doc = "\\param address address to send."]
    #[doc = ""]
    #[doc = "\\return true if the address has been send, false if something went wrong."]
    pub fn fifoSendAddress(
        channel: ::std::os::raw::c_int,
        address: *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Send a 32bit value."]
    #[doc = ""]
    #[doc = "Transmits a 32bit value to the other CPU."]
    #[doc = ""]
    #[doc = "\\param channel channel number to send to"]
    #[doc = "\\param value32 32bit value to send"]
    #[doc = ""]
    #[doc = "\\return true if the value has been send, false if something went wrong."]
    #[doc = ""]
    #[doc = "\\note Transfer is more efficient if the top 8 bits are zero. So sending smaller values or bitmasks that don't include the top bits is preferred."]
    pub fn fifoSendValue32(channel: ::std::os::raw::c_int, value32: u32) -> bool;
}
extern "C" {
    #[doc = "\\brief Send a sequence of bytes to the other CPU."]
    #[doc = ""]
    #[doc = "num_bytes can be between 0 and FIFO_MAX_DATA_BYTES - sending 0 bytes can be useful sometimes..."]
    #[doc = ""]
    #[doc = "\\param channel channel number to send to"]
    #[doc = "\\param num_bytes number of bytes to send"]
    #[doc = "\\param data_array pointer to data array"]
    #[doc = ""]
    #[doc = "\\return true if the data message has been send, false if something went wrong."]
    pub fn fifoSendDatamsg(
        channel: ::std::os::raw::c_int,
        num_bytes: ::std::os::raw::c_int,
        data_array: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Set user address message callback."]
    #[doc = ""]
    #[doc = "Set a callback to receive incoming address messages on a specific channel."]
    #[doc = ""]
    #[doc = "\\param channel channel number to send to."]
    #[doc = "\\param newhandler a function pointer to the new handler function."]
    #[doc = "\\param userdata a pointer that will be passed on to the handler when it will be called."]
    #[doc = ""]
    #[doc = "\\return true if the handler has been set, false if something went wrong."]
    #[doc = ""]
    #[doc = "\\note Setting the handler for a channel feeds the queue of buffered messages to the new handler, if there are any unread messages."]
    pub fn fifoSetAddressHandler(
        channel: ::std::os::raw::c_int,
        newhandler: FifoAddressHandlerFunc,
        userdata: *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Set user value32 message callback."]
    #[doc = ""]
    #[doc = "Set a callback to receive incoming value32 messages on a specific channel."]
    #[doc = ""]
    #[doc = "\\param channel channel number to send to."]
    #[doc = "\\param newhandler a function pointer to the new handler function."]
    #[doc = "\\param userdata a pointer that will be passed on to the handler when it will be called."]
    #[doc = ""]
    #[doc = "\\return true if the handler has been set, false if something went wrong."]
    #[doc = ""]
    #[doc = "\\note Setting the handler for a channel feeds the queue of buffered messages to the new handler, if there are any unread messages."]
    pub fn fifoSetValue32Handler(
        channel: ::std::os::raw::c_int,
        newhandler: FifoValue32HandlerFunc,
        userdata: *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Set user data message callback."]
    #[doc = ""]
    #[doc = "Set a callback to receive incoming data messages on a specific channel."]
    #[doc = ""]
    #[doc = "\\param channel channel number to send to."]
    #[doc = "\\param newhandler a function pointer to the new handler function."]
    #[doc = "\\param userdata a pointer that will be passed on to the handler when it will be called."]
    #[doc = ""]
    #[doc = "\\return true if the handler has been set, false if something went wrong."]
    #[doc = ""]
    #[doc = "\\note Setting the handler for a channel feeds the queue of buffered messages to the new handler, if there are any unread messages."]
    pub fn fifoSetDatamsgHandler(
        channel: ::std::os::raw::c_int,
        newhandler: FifoDatamsgHandlerFunc,
        userdata: *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief checks if there is any addresses in the fifo queue."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = ""]
    #[doc = "\\return true if there is any addresses in the queue and if there isn't an address handler in place for the channel."]
    pub fn fifoCheckAddress(channel: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief checks if there is any values in the fifo queue."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = ""]
    #[doc = "\\return true if there is any values in the queue and if there isn't a value handler in place for the channel."]
    pub fn fifoCheckValue32(channel: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief checks if there is any data messages in the fifo queue."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = ""]
    #[doc = "\\return true if there is any data messages in the queue and if there isn't a data message handler in place for the channel."]
    pub fn fifoCheckDatamsg(channel: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief gets the number of bytes in the queue for the first data entry."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = ""]
    #[doc = "\\return the number of bytes in the queue for the first data entry, or -1 if there are no entries."]
    pub fn fifoCheckDatamsgLength(channel: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Get the first address in queue for a specific channel."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = ""]
    #[doc = "\\return the first address in queue, or NULL if there is none."]
    pub fn fifoGetAddress(channel: ::std::os::raw::c_int) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = "\\brief Get the first value32 in queue for a specific channel."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = ""]
    #[doc = "\\return the first value32 in queue, or 0 if there is no message."]
    pub fn fifoGetValue32(channel: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    #[doc = "\\brief Reads a data message in a given buffer and returns the number of bytes written."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = "\\param buffersize the size of the buffer where the message will be copied to."]
    #[doc = "\\param destbuffer a pointer to the buffer where the message will be copied to."]
    #[doc = ""]
    #[doc = "\\return the number of bytes written, or -1 if there is no message."]
    #[doc = ""]
    #[doc = "\\warning If your buffer is not big enough, you may lose data! Check the data length first if you're not sure what the size is."]
    pub fn fifoGetDatamsg(
        channel: ::std::os::raw::c_int,
        buffersize: ::std::os::raw::c_int,
        destbuffer: *mut u8,
    ) -> ::std::os::raw::c_int;
}
#[doc = "! holds data related to the touch screen."]
#[repr(C)]
pub struct touchPosition {
    #[doc = "!< Raw x value from the A2D"]
    pub rawx: u16,
    #[doc = "!< Raw y value from the A2D"]
    pub rawy: u16,
    #[doc = "!< Processes pixel X value"]
    pub px: u16,
    #[doc = "!< Processes pixel Y value"]
    pub py: u16,
    #[doc = "!< Raw cross panel resistance"]
    pub z1: u16,
    #[doc = "!< Raw cross panel resistance"]
    pub z2: u16,
}
#[test]
fn bindgen_test_layout_touchPosition() {
    assert_eq!(
        ::core::mem::size_of::<touchPosition>(),
        12usize,
        concat!("Size of: ", stringify!(touchPosition))
    );
    assert_eq!(
        ::core::mem::align_of::<touchPosition>(),
        2usize,
        concat!("Alignment of ", stringify!(touchPosition))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).rawx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(rawx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).rawy as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(rawy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).px as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(px)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).py as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(py)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).z1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(z1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).z2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(z2)
        )
    );
}
#[doc = "!< Keypad A button."]
pub const KEY_A: KEYPAD_BITS = 1;
#[doc = "!< Keypad B button."]
pub const KEY_B: KEYPAD_BITS = 2;
#[doc = "!< Keypad SELECT button."]
pub const KEY_SELECT: KEYPAD_BITS = 4;
#[doc = "!< Keypad START button."]
pub const KEY_START: KEYPAD_BITS = 8;
#[doc = "!< Keypad RIGHT button."]
pub const KEY_RIGHT: KEYPAD_BITS = 16;
#[doc = "!< Keypad LEFT button."]
pub const KEY_LEFT: KEYPAD_BITS = 32;
#[doc = "!< Keypad UP button."]
pub const KEY_UP: KEYPAD_BITS = 64;
#[doc = "!< Keypad DOWN button."]
pub const KEY_DOWN: KEYPAD_BITS = 128;
#[doc = "!< Right shoulder button."]
pub const KEY_R: KEYPAD_BITS = 256;
#[doc = "!< Left shoulder button."]
pub const KEY_L: KEYPAD_BITS = 512;
#[doc = "!< Keypad X button."]
pub const KEY_X: KEYPAD_BITS = 1024;
#[doc = "!< Keypad Y button."]
pub const KEY_Y: KEYPAD_BITS = 2048;
#[doc = "!< Touchscreen pendown."]
pub const KEY_TOUCH: KEYPAD_BITS = 4096;
#[doc = "!< Lid state."]
pub const KEY_LID: KEYPAD_BITS = 8192;
#[doc = "! enum values for the keypad buttons."]
pub type KEYPAD_BITS = u32;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = u128;
#[repr(C)]
pub struct swiSHA1context {
    #[doc = "< intermediate digest state"]
    pub state: [u32; 5usize],
    #[doc = "< number of bytes processed"]
    pub total: [u32; 2usize],
    #[doc = "< data block being processed"]
    pub buffer: [u8; 64usize],
    pub fragment_size: u32,
    #[doc = "< data block being processed"]
    pub sha_block: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut swiSHA1context, src: *const ::core::ffi::c_void, len: usize),
    >,
}
#[test]
fn bindgen_test_layout_swiSHA1context() {
    assert_eq!(
        ::core::mem::size_of::<swiSHA1context>(),
        104usize,
        concat!("Size of: ", stringify!(swiSHA1context))
    );
    assert_eq!(
        ::core::mem::align_of::<swiSHA1context>(),
        8usize,
        concat!("Alignment of ", stringify!(swiSHA1context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swiSHA1context>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(swiSHA1context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swiSHA1context>())).total as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(swiSHA1context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swiSHA1context>())).buffer as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(swiSHA1context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swiSHA1context>())).fragment_size as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(swiSHA1context),
            "::",
            stringify!(fragment_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swiSHA1context>())).sha_block as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(swiSHA1context),
            "::",
            stringify!(sha_block)
        )
    );
}
pub type swiSHA1context_t = swiSHA1context;
extern "C" {
    #[doc = " \\brief          SHA-1 context setup"]
    #[doc = ""]
    #[doc = " \\param ctx      context to be initialized"]
    pub fn swiSHA1Init(ctx: *mut swiSHA1context_t);
}
extern "C" {
    #[doc = " \\brief          SHA-1 process buffer"]
    #[doc = ""]
    #[doc = " \\param ctx      SHA-1 context"]
    #[doc = " \\param data     buffer to process"]
    #[doc = " \\param len      length of data"]
    pub fn swiSHA1Update(ctx: *mut swiSHA1context_t, data: *const ::core::ffi::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief          SHA-1 final digest"]
    #[doc = ""]
    #[doc = " \\param digest   buffer to hold SHA-1 checksum result"]
    #[doc = " \\param ctx      SHA-1 context"]
    pub fn swiSHA1Final(digest: *mut ::core::ffi::c_void, ctx: *mut swiSHA1context_t);
}
extern "C" {
    #[doc = " \\brief          SHA-1 checksum"]
    #[doc = ""]
    #[doc = " \\param digest   buffer to hold SHA-1 checksum result"]
    #[doc = " \\param data     buffer to process"]
    #[doc = " \\param len      length of data"]
    pub fn swiSHA1Calc(
        digest: *mut ::core::ffi::c_void,
        data: *const ::core::ffi::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief          SHA-1 verify"]
    #[doc = ""]
    #[doc = " \\param digest1  buffer containing hash to verify"]
    #[doc = " \\param digest2  buffer containing hash to verify"]
    pub fn swiSHA1Verify(digest1: *const ::core::ffi::c_void, digest2: *const ::core::ffi::c_void);
}
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type __ino_t = __uint32_t;
pub type __dev_t = __uint32_t;
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
#[test]
fn bindgen_test_layout___lock_t() {
    assert_eq!(
        ::core::mem::size_of::<__lock_t>(),
        12usize,
        concat!("Size of: ", stringify!(__lock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__lock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__lock_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__lock_t>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lock_t),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__lock_t>())).thread_tag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__lock_t),
            "::",
            stringify!(thread_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__lock_t>())).counter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lock_t),
            "::",
            stringify!(counter)
        )
    );
}
pub type _LOCK_RECURSIVE_T = __lock_t;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T)
        -> ::std::os::raw::c_int;
}
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type __pid_t = ::std::os::raw::c_int;
pub type __uid_t = ::std::os::raw::c_ushort;
pub type __gid_t = ::std::os::raw::c_ushort;
pub type __id_t = __uint32_t;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::std::os::raw::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::std::os::raw::c_long;
pub type __size_t = ::std::os::raw::c_ulong;
pub type _ssize_t = ::std::os::raw::c_long;
pub type __ssize_t = _ssize_t;
pub type wint_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::std::os::raw::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut ::core::ffi::c_void;
pub type __clock_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __clockid_t = ::std::os::raw::c_ulong;
pub type __timer_t = ::std::os::raw::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::std::os::raw::c_int;
pub type __nlink_t = ::std::os::raw::c_ushort;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_ulong;
pub type __va_list = *mut ::std::os::raw::c_char;
pub type __ULong = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::std::os::raw::c_int,
    pub _maxwds: ::std::os::raw::c_int,
    pub _sign: ::std::os::raw::c_int,
    pub _wds: ::std::os::raw::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    assert_eq!(
        ::core::mem::size_of::<_Bigint>(),
        32usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::core::mem::align_of::<_Bigint>(),
        8usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._k as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._maxwds as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._sign as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._wds as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::std::os::raw::c_int,
    pub __tm_min: ::std::os::raw::c_int,
    pub __tm_hour: ::std::os::raw::c_int,
    pub __tm_mday: ::std::os::raw::c_int,
    pub __tm_mon: ::std::os::raw::c_int,
    pub __tm_year: ::std::os::raw::c_int,
    pub __tm_wday: ::std::os::raw::c_int,
    pub __tm_yday: ::std::os::raw::c_int,
    pub __tm_isdst: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    assert_eq!(
        ::core::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::core::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut ::core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    assert_eq!(
        ::core::mem::size_of::<_on_exit_args>(),
        520usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::core::mem::align_of::<_on_exit_args>(),
        8usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._fnargs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._dso_handle as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._fntypes as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._is_cxa as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::std::os::raw::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    assert_eq!(
        ::core::mem::size_of::<_atexit>(),
        792usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::core::mem::align_of::<_atexit>(),
        8usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._ind as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._fns as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._on_exit_args as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *mut ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *const ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: _fpos_t,
            arg4: ::std::os::raw::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::std::os::raw::c_uchar,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        184usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._read as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._write as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._close as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._up as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._data as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lock as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._mbstate as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._flags2 as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::std::os::raw::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    assert_eq!(
        ::core::mem::size_of::<_glue>(),
        24usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::core::mem::align_of::<_glue>(),
        8usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._niobs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._iobs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::std::os::raw::c_ushort; 3usize],
    pub _mult: [::std::os::raw::c_ushort; 3usize],
    pub _add: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
    assert_eq!(
        ::core::mem::size_of::<_rand48>(),
        14usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::core::mem::align_of::<_rand48>(),
        2usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._seed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._mult as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._add as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::std::os::raw::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::std::os::raw::c_int,
    pub _emergency: [::std::os::raw::c_char; 25usize],
    pub _unspecified_locale_info: ::std::os::raw::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: ::std::os::raw::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::std::os::raw::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::std::os::raw::c_int,
    pub _cvtbuf: *mut ::std::os::raw::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
    pub deviceData: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 45usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: ::std::os::raw::c_uint,
    pub _strtok_last: *mut ::std::os::raw::c_char,
    pub _asctime_buf: [::std::os::raw::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::std::os::raw::c_int,
    pub _rand_next: ::std::os::raw::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::std::os::raw::c_char; 8usize],
    pub _signal_buf: [::std::os::raw::c_char; 24usize],
    pub _getdate_err: ::std::os::raw::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        216usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._unused_rand as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_unused_rand)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._strtok_last as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._asctime_buf as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._localtime_buf
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._gamma_signgam
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._rand_next as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_rand_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._r48 as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mblen_state as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbtowc_state
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wctomb_state
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._l64a_buf as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._signal_buf as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_signal_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._getdate_err as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbrlen_state
                as *const _ as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbrtowc_state
                as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbsrtowcs_state
                as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wcrtomb_state
                as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wcsrtombs_state
                as *const _ as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._h_errno as *const _
                as usize
        },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_h_errno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut ::std::os::raw::c_uchar; 30usize],
    pub _nmalloc: [::std::os::raw::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        360usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_2>()))._nextf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nextf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_2>()))._nmalloc as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nmalloc)
        )
    );
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1>(),
        360usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent__bindgen_ty_1>()))._reent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_reent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent__bindgen_ty_1>()))._unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_unused)
        )
    );
}
#[test]
fn bindgen_test_layout__reent() {
    assert_eq!(
        ::core::mem::size_of::<_reent>(),
        1896usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._errno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stdin as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stdout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stderr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._inc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._emergency as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent>()))._unspecified_locale_info as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_unspecified_locale_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._locale as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sdidinit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sdidinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__cleanup as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._result as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._result_k as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._p5s as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._freelist as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_freelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._cvtlen as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._cvtbuf as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._new as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._atexit as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._atexit0 as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._sig_func as *const _ as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sglue as *const _ as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sglue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sf as *const _ as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).deviceData as *const _ as usize },
        1888usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(deviceData)
        )
    );
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::core::ffi::c_void, arg2: usize);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoi_r(
        arg1: *mut _reent,
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atol_r(
        arg1: *mut _reent,
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::core::ffi::c_void,
        __base: *const ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn calloc(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn free(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn getenv(__string: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: ::std::os::raw::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mkstemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mktemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realloc(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn reallocf(arg1: *mut ::core::ffi::c_void, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const ::std::os::raw::c_char,
        resolved_path: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn system(__string: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn a64l(__input: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(__input: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _l64a_r(
        arg1: *mut _reent,
        __input: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *mut ::core::ffi::c_void),
        >,
        __arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_r(
        arg1: *mut _reent,
        __string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _jrand48_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _nrand48_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _system_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
        arg4: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut ::core::ffi::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
                arg3: *const ::core::ffi::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn aligned_alloc(arg1: usize, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: ::std::os::raw::c_int);
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const ::core::ffi::c_void, arg2: *mut ::core::ffi::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut ::core::ffi::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::core::ffi::c_void, arg2: usize);
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::core::ffi::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strdup_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__signo: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
#[doc = "! A resizable array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DynamicArray {
    #[doc = "!< pointer to array of void pointers"]
    pub data: *mut *mut ::core::ffi::c_void,
    #[doc = "!< currently allocated size of the array"]
    pub cur_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_DynamicArray() {
    assert_eq!(
        ::core::mem::size_of::<DynamicArray>(),
        16usize,
        concat!("Size of: ", stringify!(DynamicArray))
    );
    assert_eq!(
        ::core::mem::align_of::<DynamicArray>(),
        8usize,
        concat!("Alignment of ", stringify!(DynamicArray))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DynamicArray>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DynamicArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DynamicArray>())).cur_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DynamicArray),
            "::",
            stringify!(cur_size)
        )
    );
}
extern "C" {
    #[doc = " \\brief Initializes an array with the supplied initial size"]
    #[doc = "\\param v the array to initialize"]
    #[doc = "\\param initialSize the initial size to allocate"]
    #[doc = "\\return a pointer to the data, or NULL on error."]
    pub fn DynamicArrayInit(
        v: *mut DynamicArray,
        initialSize: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " \\brief Frees memory allocated by the dynamic array"]
    #[doc = "\\param v The array to delete"]
    pub fn DynamicArrayDelete(v: *mut DynamicArray);
}
extern "C" {
    #[doc = " \\brief Gets the entry at the supplied index"]
    #[doc = "\\param v The array to get from."]
    #[doc = "\\param index The index of the data to get."]
    #[doc = "\\return The data or NULL if v is NULL or the index is out of range."]
    pub fn DynamicArrayGet(
        v: *mut DynamicArray,
        index: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " \\brief Sets the entry to the supplied value"]
    #[doc = "\\param v The array to set"]
    #[doc = "\\param index The index of the data to set (array will be resized to fit the index)."]
    #[doc = "\\param item The data to set."]
    #[doc = "\\return false if v is NULL or there isn't enough memory, true otherwise"]
    pub fn DynamicArraySet(
        v: *mut DynamicArray,
        index: ::std::os::raw::c_uint,
        item: *mut ::core::ffi::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo {
    pub arena: usize,
    pub ordblks: usize,
    pub smblks: usize,
    pub hblks: usize,
    pub hblkhd: usize,
    pub usmblks: usize,
    pub fsmblks: usize,
    pub uordblks: usize,
    pub fordblks: usize,
    pub keepcost: usize,
}
#[test]
fn bindgen_test_layout_mallinfo() {
    assert_eq!(
        ::core::mem::size_of::<mallinfo>(),
        80usize,
        concat!("Size of: ", stringify!(mallinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<mallinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(mallinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mallinfo>())).arena as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(arena)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mallinfo>())).ordblks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(ordblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mallinfo>())).smblks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(smblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mallinfo>())).hblks as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(hblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mallinfo>())).hblkhd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(hblkhd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mallinfo>())).usmblks as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(usmblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mallinfo>())).fsmblks as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(fsmblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mallinfo>())).uordblks as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(uordblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mallinfo>())).fordblks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(fordblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mallinfo>())).keepcost as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(keepcost)
        )
    );
}
extern "C" {
    pub fn memalign(arg1: usize, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _memalign_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mallinfo() -> mallinfo;
}
extern "C" {
    pub fn _mallinfo_r(arg1: *mut _reent) -> mallinfo;
}
extern "C" {
    pub fn malloc_stats();
}
extern "C" {
    pub fn _malloc_stats_r(arg1: *mut _reent);
}
extern "C" {
    pub fn mallopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mallopt_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc_usable_size(arg1: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn _malloc_usable_size_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _valloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn pvalloc(arg1: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _pvalloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn malloc_trim(arg1: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _malloc_trim_r(arg1: *mut _reent, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __malloc_lock(arg1: *mut _reent);
}
extern "C" {
    pub fn __malloc_unlock(arg1: *mut _reent);
}
extern "C" {
    pub fn mstats(arg1: *mut ::std::os::raw::c_char);
}
#[doc = "! A node for the linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedList {
    #[doc = "!< A pointer to the next node."]
    pub next: *mut LinkedList,
    #[doc = "!< A pointer to the previous node."]
    pub prev: *mut LinkedList,
    #[doc = "!< A pointer to some data."]
    pub data: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_LinkedList() {
    assert_eq!(
        ::core::mem::size_of::<LinkedList>(),
        24usize,
        concat!("Size of: ", stringify!(LinkedList))
    );
    assert_eq!(
        ::core::mem::align_of::<LinkedList>(),
        8usize,
        concat!("Alignment of ", stringify!(LinkedList))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LinkedList>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LinkedList>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedList),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LinkedList>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LinkedList),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = "\\brief Adds data to a linked list."]
    #[doc = ""]
    #[doc = "This will only store the pointer to the data, so you have to make sure that the pointer stays valid."]
    #[doc = ""]
    #[doc = "\\param front A pointer to a pointer to the front of the linked list (or a pointer to NULL if you don't have a linked list yet)."]
    #[doc = "\\param data A pointer to the data you want to store."]
    #[doc = ""]
    #[doc = "\\return A pointer to the new node, which is also the new front, or NULL if there is not enough memory."]
    pub fn linkedlistAdd(
        front: *mut *mut LinkedList,
        data: *mut ::core::ffi::c_void,
    ) -> *mut LinkedList;
}
extern "C" {
    #[doc = "\\brief Removes a node from a linked list."]
    #[doc = ""]
    #[doc = "The data pointer of the node will be lost after this, so make sure you don't need it anymore."]
    #[doc = ""]
    #[doc = "\\param node The node you want to remove."]
    pub fn linkedlistRemove(node: *mut LinkedList);
}
extern "C" {
    pub fn __sassert(
        fileName: *const ::std::os::raw::c_char,
        lineNumber: ::std::os::raw::c_int,
        conditionString: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub static mut mosaicShadow: u16;
}
extern "C" {
    pub static mut mosaicShadowSub: u16;
}
pub const VRAM_A_LCD: VRAM_A_TYPE = 0;
pub const VRAM_A_MAIN_BG: VRAM_A_TYPE = 1;
pub const VRAM_A_MAIN_BG_0x06000000: VRAM_A_TYPE = 1;
pub const VRAM_A_MAIN_BG_0x06020000: VRAM_A_TYPE = 9;
pub const VRAM_A_MAIN_BG_0x06040000: VRAM_A_TYPE = 17;
pub const VRAM_A_MAIN_BG_0x06060000: VRAM_A_TYPE = 25;
pub const VRAM_A_MAIN_SPRITE: VRAM_A_TYPE = 2;
pub const VRAM_A_MAIN_SPRITE_0x06400000: VRAM_A_TYPE = 2;
pub const VRAM_A_MAIN_SPRITE_0x06420000: VRAM_A_TYPE = 10;
pub const VRAM_A_TEXTURE: VRAM_A_TYPE = 3;
pub const VRAM_A_TEXTURE_SLOT0: VRAM_A_TYPE = 3;
pub const VRAM_A_TEXTURE_SLOT1: VRAM_A_TYPE = 11;
pub const VRAM_A_TEXTURE_SLOT2: VRAM_A_TYPE = 19;
pub const VRAM_A_TEXTURE_SLOT3: VRAM_A_TYPE = 27;
pub type VRAM_A_TYPE = u32;
pub const VRAM_B_LCD: VRAM_B_TYPE = 0;
pub const VRAM_B_MAIN_BG: VRAM_B_TYPE = 9;
pub const VRAM_B_MAIN_BG_0x06000000: VRAM_B_TYPE = 1;
pub const VRAM_B_MAIN_BG_0x06020000: VRAM_B_TYPE = 9;
pub const VRAM_B_MAIN_BG_0x06040000: VRAM_B_TYPE = 17;
pub const VRAM_B_MAIN_BG_0x06060000: VRAM_B_TYPE = 25;
pub const VRAM_B_MAIN_SPRITE: VRAM_B_TYPE = 2;
pub const VRAM_B_MAIN_SPRITE_0x06400000: VRAM_B_TYPE = 2;
pub const VRAM_B_MAIN_SPRITE_0x06420000: VRAM_B_TYPE = 10;
pub const VRAM_B_TEXTURE: VRAM_B_TYPE = 11;
pub const VRAM_B_TEXTURE_SLOT0: VRAM_B_TYPE = 3;
pub const VRAM_B_TEXTURE_SLOT1: VRAM_B_TYPE = 11;
pub const VRAM_B_TEXTURE_SLOT2: VRAM_B_TYPE = 19;
pub const VRAM_B_TEXTURE_SLOT3: VRAM_B_TYPE = 27;
pub type VRAM_B_TYPE = u32;
pub const VRAM_C_LCD: VRAM_C_TYPE = 0;
pub const VRAM_C_MAIN_BG: VRAM_C_TYPE = 17;
pub const VRAM_C_MAIN_BG_0x06000000: VRAM_C_TYPE = 1;
pub const VRAM_C_MAIN_BG_0x06020000: VRAM_C_TYPE = 9;
pub const VRAM_C_MAIN_BG_0x06040000: VRAM_C_TYPE = 17;
pub const VRAM_C_MAIN_BG_0x06060000: VRAM_C_TYPE = 25;
pub const VRAM_C_ARM7: VRAM_C_TYPE = 2;
pub const VRAM_C_ARM7_0x06000000: VRAM_C_TYPE = 2;
pub const VRAM_C_ARM7_0x06020000: VRAM_C_TYPE = 10;
pub const VRAM_C_SUB_BG: VRAM_C_TYPE = 4;
pub const VRAM_C_SUB_BG_0x06200000: VRAM_C_TYPE = 4;
pub const VRAM_C_TEXTURE: VRAM_C_TYPE = 19;
pub const VRAM_C_TEXTURE_SLOT0: VRAM_C_TYPE = 3;
pub const VRAM_C_TEXTURE_SLOT1: VRAM_C_TYPE = 11;
pub const VRAM_C_TEXTURE_SLOT2: VRAM_C_TYPE = 19;
pub const VRAM_C_TEXTURE_SLOT3: VRAM_C_TYPE = 27;
pub type VRAM_C_TYPE = u32;
pub const VRAM_D_LCD: VRAM_D_TYPE = 0;
pub const VRAM_D_MAIN_BG: VRAM_D_TYPE = 25;
pub const VRAM_D_MAIN_BG_0x06000000: VRAM_D_TYPE = 1;
pub const VRAM_D_MAIN_BG_0x06020000: VRAM_D_TYPE = 9;
pub const VRAM_D_MAIN_BG_0x06040000: VRAM_D_TYPE = 17;
pub const VRAM_D_MAIN_BG_0x06060000: VRAM_D_TYPE = 25;
pub const VRAM_D_ARM7: VRAM_D_TYPE = 10;
pub const VRAM_D_ARM7_0x06000000: VRAM_D_TYPE = 2;
pub const VRAM_D_ARM7_0x06020000: VRAM_D_TYPE = 10;
pub const VRAM_D_SUB_SPRITE: VRAM_D_TYPE = 4;
pub const VRAM_D_TEXTURE: VRAM_D_TYPE = 27;
pub const VRAM_D_TEXTURE_SLOT0: VRAM_D_TYPE = 3;
pub const VRAM_D_TEXTURE_SLOT1: VRAM_D_TYPE = 11;
pub const VRAM_D_TEXTURE_SLOT2: VRAM_D_TYPE = 19;
pub const VRAM_D_TEXTURE_SLOT3: VRAM_D_TYPE = 27;
pub type VRAM_D_TYPE = u32;
pub const VRAM_E_LCD: VRAM_E_TYPE = 0;
pub const VRAM_E_MAIN_BG: VRAM_E_TYPE = 1;
pub const VRAM_E_MAIN_SPRITE: VRAM_E_TYPE = 2;
pub const VRAM_E_TEX_PALETTE: VRAM_E_TYPE = 3;
pub const VRAM_E_BG_EXT_PALETTE: VRAM_E_TYPE = 4;
pub type VRAM_E_TYPE = u32;
pub const VRAM_F_LCD: VRAM_F_TYPE = 0;
pub const VRAM_F_MAIN_BG: VRAM_F_TYPE = 1;
pub const VRAM_F_MAIN_BG_0x06000000: VRAM_F_TYPE = 1;
pub const VRAM_F_MAIN_BG_0x06004000: VRAM_F_TYPE = 9;
pub const VRAM_F_MAIN_BG_0x06010000: VRAM_F_TYPE = 17;
pub const VRAM_F_MAIN_BG_0x06014000: VRAM_F_TYPE = 25;
pub const VRAM_F_MAIN_SPRITE: VRAM_F_TYPE = 2;
pub const VRAM_F_MAIN_SPRITE_0x06400000: VRAM_F_TYPE = 2;
pub const VRAM_F_MAIN_SPRITE_0x06404000: VRAM_F_TYPE = 10;
pub const VRAM_F_MAIN_SPRITE_0x06410000: VRAM_F_TYPE = 18;
pub const VRAM_F_MAIN_SPRITE_0x06414000: VRAM_F_TYPE = 26;
pub const VRAM_F_TEX_PALETTE: VRAM_F_TYPE = 3;
pub const VRAM_F_TEX_PALETTE_SLOT0: VRAM_F_TYPE = 3;
pub const VRAM_F_TEX_PALETTE_SLOT1: VRAM_F_TYPE = 11;
pub const VRAM_F_TEX_PALETTE_SLOT4: VRAM_F_TYPE = 19;
pub const VRAM_F_TEX_PALETTE_SLOT5: VRAM_F_TYPE = 27;
pub const VRAM_F_BG_EXT_PALETTE: VRAM_F_TYPE = 4;
pub const VRAM_F_BG_EXT_PALETTE_SLOT01: VRAM_F_TYPE = 4;
pub const VRAM_F_BG_EXT_PALETTE_SLOT23: VRAM_F_TYPE = 12;
pub const VRAM_F_SPRITE_EXT_PALETTE: VRAM_F_TYPE = 5;
pub type VRAM_F_TYPE = u32;
pub const VRAM_G_LCD: VRAM_G_TYPE = 0;
pub const VRAM_G_MAIN_BG: VRAM_G_TYPE = 1;
pub const VRAM_G_MAIN_BG_0x06000000: VRAM_G_TYPE = 1;
pub const VRAM_G_MAIN_BG_0x06004000: VRAM_G_TYPE = 9;
pub const VRAM_G_MAIN_BG_0x06010000: VRAM_G_TYPE = 17;
pub const VRAM_G_MAIN_BG_0x06014000: VRAM_G_TYPE = 25;
pub const VRAM_G_MAIN_SPRITE: VRAM_G_TYPE = 2;
pub const VRAM_G_MAIN_SPRITE_0x06400000: VRAM_G_TYPE = 2;
pub const VRAM_G_MAIN_SPRITE_0x06404000: VRAM_G_TYPE = 10;
pub const VRAM_G_MAIN_SPRITE_0x06410000: VRAM_G_TYPE = 18;
pub const VRAM_G_MAIN_SPRITE_0x06414000: VRAM_G_TYPE = 26;
pub const VRAM_G_TEX_PALETTE: VRAM_G_TYPE = 3;
pub const VRAM_G_TEX_PALETTE_SLOT0: VRAM_G_TYPE = 3;
pub const VRAM_G_TEX_PALETTE_SLOT1: VRAM_G_TYPE = 11;
pub const VRAM_G_TEX_PALETTE_SLOT4: VRAM_G_TYPE = 19;
pub const VRAM_G_TEX_PALETTE_SLOT5: VRAM_G_TYPE = 27;
pub const VRAM_G_BG_EXT_PALETTE: VRAM_G_TYPE = 4;
pub const VRAM_G_BG_EXT_PALETTE_SLOT01: VRAM_G_TYPE = 4;
pub const VRAM_G_BG_EXT_PALETTE_SLOT23: VRAM_G_TYPE = 12;
pub const VRAM_G_SPRITE_EXT_PALETTE: VRAM_G_TYPE = 5;
pub type VRAM_G_TYPE = u32;
pub const VRAM_H_LCD: VRAM_H_TYPE = 0;
pub const VRAM_H_SUB_BG: VRAM_H_TYPE = 1;
pub const VRAM_H_SUB_BG_EXT_PALETTE: VRAM_H_TYPE = 2;
pub type VRAM_H_TYPE = u32;
pub const VRAM_I_LCD: VRAM_I_TYPE = 0;
pub const VRAM_I_SUB_BG_0x06208000: VRAM_I_TYPE = 1;
pub const VRAM_I_SUB_SPRITE: VRAM_I_TYPE = 2;
pub const VRAM_I_SUB_SPRITE_EXT_PALETTE: VRAM_I_TYPE = 3;
pub type VRAM_I_TYPE = u32;
pub type _palette = [u16; 256usize];
pub type _ext_palette = [_palette; 16usize];
extern "C" {
    pub fn vramSetPrimaryBanks(
        a: VRAM_A_TYPE,
        b: VRAM_B_TYPE,
        c: VRAM_C_TYPE,
        d: VRAM_D_TYPE,
    ) -> u32;
}
extern "C" {
    pub fn vramSetMainBanks(a: VRAM_A_TYPE, b: VRAM_B_TYPE, c: VRAM_C_TYPE, d: VRAM_D_TYPE) -> u32;
}
extern "C" {
    pub fn vramSetBanks_EFG(e: VRAM_E_TYPE, f: VRAM_F_TYPE, g: VRAM_G_TYPE) -> u32;
}
extern "C" {
    pub fn vramDefault() -> u32;
}
extern "C" {
    pub fn vramRestorePrimaryBanks(vramTemp: u32);
}
extern "C" {
    pub fn vramRestoreMainBanks(vramTemp: u32);
}
extern "C" {
    pub fn vramRestoreBanks_EFG(vramTemp: u32);
}
pub const MODE_0_2D: VideoMode = 65536;
pub const MODE_1_2D: VideoMode = 65537;
pub const MODE_2_2D: VideoMode = 65538;
pub const MODE_3_2D: VideoMode = 65539;
pub const MODE_4_2D: VideoMode = 65540;
pub const MODE_5_2D: VideoMode = 65541;
pub const MODE_6_2D: VideoMode = 65542;
pub const MODE_0_3D: VideoMode = 65800;
pub const MODE_1_3D: VideoMode = 65801;
pub const MODE_2_3D: VideoMode = 65802;
pub const MODE_3_3D: VideoMode = 65803;
pub const MODE_4_3D: VideoMode = 65804;
pub const MODE_5_3D: VideoMode = 65805;
pub const MODE_6_3D: VideoMode = 65806;
pub const MODE_FIFO: VideoMode = 196608;
pub const MODE_FB0: VideoMode = 131072;
pub const MODE_FB1: VideoMode = 393216;
pub const MODE_FB2: VideoMode = 655360;
pub const MODE_FB3: VideoMode = 917504;
pub type VideoMode = u32;
extern "C" {
    pub fn setBrightness(screen: ::std::os::raw::c_int, level: ::std::os::raw::c_int);
}
#[doc = "\t\\brief register overlay for scroll registers"]
#[repr(C)]
pub struct bg_scroll {
    #[doc = "< x scroll"]
    pub x: u16,
    #[doc = "< y scroll"]
    pub y: u16,
}
#[test]
fn bindgen_test_layout_bg_scroll() {
    assert_eq!(
        ::core::mem::size_of::<bg_scroll>(),
        4usize,
        concat!("Size of: ", stringify!(bg_scroll))
    );
    assert_eq!(
        ::core::mem::align_of::<bg_scroll>(),
        2usize,
        concat!("Alignment of ", stringify!(bg_scroll))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bg_scroll>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bg_scroll),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bg_scroll>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bg_scroll),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "\t\\brief register overlay for affine matrix registers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bg_transform {
    #[doc = "!< The change in x per horizontal pixel."]
    pub hdx: s16,
    #[doc = "!< The change in x per vertical pixel."]
    pub vdx: s16,
    #[doc = "!< The change in y per horizontal pixel."]
    pub hdy: s16,
    #[doc = "!< The change in x per vertical pixel."]
    pub vdy: s16,
    #[doc = "!< map x value which corresponds to the screen origin"]
    pub dx: s32,
    #[doc = "!< map y value which corresponds to the screen origin"]
    pub dy: s32,
}
#[test]
fn bindgen_test_layout_bg_transform() {
    assert_eq!(
        ::core::mem::size_of::<bg_transform>(),
        16usize,
        concat!("Size of: ", stringify!(bg_transform))
    );
    assert_eq!(
        ::core::mem::align_of::<bg_transform>(),
        4usize,
        concat!("Alignment of ", stringify!(bg_transform))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bg_transform>())).hdx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bg_transform),
            "::",
            stringify!(hdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bg_transform>())).vdx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bg_transform),
            "::",
            stringify!(vdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bg_transform>())).hdy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bg_transform),
            "::",
            stringify!(hdy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bg_transform>())).vdy as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(bg_transform),
            "::",
            stringify!(vdy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bg_transform>())).dx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bg_transform),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bg_transform>())).dy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bg_transform),
            "::",
            stringify!(dy)
        )
    );
}
#[doc = "\t\\brief register overlay for background attribute registers"]
#[repr(C)]
pub struct bg_attribute {
    #[doc = "< Background control registers"]
    pub control: [u16; 4usize],
    #[doc = "< Background scroll registers"]
    pub scroll: [bg_scroll; 4usize],
    #[doc = "< Background 2 affine matrix"]
    pub bg2_rotation: bg_transform,
    #[doc = "< Background 3 affine matrix"]
    pub bg3_rotation: bg_transform,
}
#[test]
fn bindgen_test_layout_bg_attribute() {
    assert_eq!(
        ::core::mem::size_of::<bg_attribute>(),
        56usize,
        concat!("Size of: ", stringify!(bg_attribute))
    );
    assert_eq!(
        ::core::mem::align_of::<bg_attribute>(),
        4usize,
        concat!("Alignment of ", stringify!(bg_attribute))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bg_attribute>())).control as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bg_attribute),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bg_attribute>())).scroll as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bg_attribute),
            "::",
            stringify!(scroll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bg_attribute>())).bg2_rotation as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bg_attribute),
            "::",
            stringify!(bg2_rotation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bg_attribute>())).bg3_rotation as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bg_attribute),
            "::",
            stringify!(bg3_rotation)
        )
    );
}
#[doc = " \\brief Overlay for 8-bit tile map entries"]
#[repr(C)]
pub struct TileMapEntry8 {
    pub index: u8,
}
#[test]
fn bindgen_test_layout_TileMapEntry8() {
    assert_eq!(
        ::core::mem::size_of::<TileMapEntry8>(),
        1usize,
        concat!("Size of: ", stringify!(TileMapEntry8))
    );
    assert_eq!(
        ::core::mem::align_of::<TileMapEntry8>(),
        1usize,
        concat!("Alignment of ", stringify!(TileMapEntry8))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TileMapEntry8>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TileMapEntry8),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " \\brief Overlay for 16-bit tile map entries"]
#[repr(C, packed)]
pub struct TileMapEntry16 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_TileMapEntry16() {
    assert_eq!(
        ::core::mem::size_of::<TileMapEntry16>(),
        2usize,
        concat!("Size of: ", stringify!(TileMapEntry16))
    );
    assert_eq!(
        ::core::mem::align_of::<TileMapEntry16>(),
        1usize,
        concat!("Alignment of ", stringify!(TileMapEntry16))
    );
}
impl TileMapEntry16 {
    #[inline]
    pub fn index(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u16) }
    }
    #[inline]
    pub fn set_index(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn hflip(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hflip(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vflip(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_vflip(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn palette(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_palette(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        index: u16,
        hflip: u16,
        vflip: u16,
        palette: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let index: u16 = unsafe { ::core::mem::transmute(index) };
            index as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let hflip: u16 = unsafe { ::core::mem::transmute(hflip) };
            hflip as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let vflip: u16 = unsafe { ::core::mem::transmute(vflip) };
            vflip as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let palette: u16 = unsafe { ::core::mem::transmute(palette) };
            palette as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< \\brief 32 x 32 tile text background"]
pub const BG_32x32: BackgroundControl = 0;
#[doc = "< \\brief 64 x 32 tile text background"]
pub const BG_64x32: BackgroundControl = 16384;
#[doc = "< \\brief 32 x 64 tile text background"]
pub const BG_32x64: BackgroundControl = 32768;
#[doc = "< \\brief 64 x 64 tile text background"]
pub const BG_64x64: BackgroundControl = 49152;
#[doc = "< \\brief 16 x 16 tile affine (rotation & scale) background"]
pub const BG_RS_16x16: BackgroundControl = 0;
#[doc = "< \\brief 32 x 32 tile affine (rotation & scale) background"]
pub const BG_RS_32x32: BackgroundControl = 16384;
#[doc = "< \\brief 64 x 64 tile affine (rotation & scale) background"]
pub const BG_RS_64x64: BackgroundControl = 32768;
#[doc = "< \\brief 128 x 128 tile affine (rotation & scale) background"]
pub const BG_RS_128x128: BackgroundControl = 49152;
#[doc = "< \\brief 128x128 pixel 8-bit bitmapped background"]
pub const BG_BMP8_128x128: BackgroundControl = 128;
#[doc = "< \\brief 256x256 pixel 8-bit bitmapped background"]
pub const BG_BMP8_256x256: BackgroundControl = 16512;
#[doc = "< \\brief 512x256 pixel 8-bit bitmapped background"]
pub const BG_BMP8_512x256: BackgroundControl = 32896;
#[doc = "< \\brief 512 pixel 8-bit bitmapped background"]
pub const BG_BMP8_512x512: BackgroundControl = 49280;
#[doc = "< \\brief 1024x512 pixel 8-bit Large bitmapped background (Mode 6 of main engine only)"]
pub const BG_BMP8_1024x512: BackgroundControl = 16384;
#[doc = "< \\brief 512x1024 pixel 8-bit Large bitmapped background (Mode 6 of main engine only)"]
pub const BG_BMP8_512x1024: BackgroundControl = 0;
#[doc = "< \\brief 128x128 pixel 16-bit bitmapped background"]
pub const BG_BMP16_128x128: BackgroundControl = 132;
#[doc = "< \\brief 256x256 pixel 16-bit bitmapped background"]
pub const BG_BMP16_256x256: BackgroundControl = 16516;
#[doc = "< \\brief 512x256 pixel 16-bit bitmapped background"]
pub const BG_BMP16_512x256: BackgroundControl = 32900;
#[doc = "< \\brief 512x512 pixel 16-bit bitmapped background"]
pub const BG_BMP16_512x512: BackgroundControl = 49284;
#[doc = "< \\brief mosaic enable"]
pub const BG_MOSAIC_ON: BackgroundControl = 64;
#[doc = "< \\brief mosaic disable"]
pub const BG_MOSAIC_OFF: BackgroundControl = 0;
#[doc = "< \\brief Lower priority will be rendered on top"]
pub const BG_PRIORITY_0: BackgroundControl = 0;
#[doc = "< \\brief Lower priority will be rendered on top"]
pub const BG_PRIORITY_1: BackgroundControl = 1;
#[doc = "< \\brief Lower priority will be rendered on top"]
pub const BG_PRIORITY_2: BackgroundControl = 2;
#[doc = "< \\brief Lower priority will be rendered on top"]
pub const BG_PRIORITY_3: BackgroundControl = 3;
#[doc = "< \\brief Disable wrapping (no effect on text backgrounds...always wrapped)"]
pub const BG_WRAP_OFF: BackgroundControl = 0;
#[doc = "< \\brief Enable wrapping (no effect on text backgrounds...always wrapped)"]
pub const BG_WRAP_ON: BackgroundControl = 8192;
#[doc = "< \\brief Use slot 0 of extended palettes"]
pub const BG_PALETTE_SLOT0: BackgroundControl = 0;
#[doc = "< \\brief Use slot 1 of extended palettes"]
pub const BG_PALETTE_SLOT1: BackgroundControl = 0;
#[doc = "< \\brief Use slot 2 of extended palettes"]
pub const BG_PALETTE_SLOT2: BackgroundControl = 8192;
#[doc = "< \\brief Use slot 3 of extended palettes"]
pub const BG_PALETTE_SLOT3: BackgroundControl = 8192;
#[doc = "< \\brief 256 color text background"]
pub const BG_COLOR_256: BackgroundControl = 128;
#[doc = "< \\brief 16x16 color text background"]
pub const BG_COLOR_16: BackgroundControl = 0;
#[doc = "\t\\brief Bit defines for the background control registers"]
pub type BackgroundControl = u32;
#[doc = " \\defgroup background_api_group \"Background API Access\""]
#[doc = "@{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BgState {
    pub angle: ::std::os::raw::c_int,
    pub centerX: s32,
    pub centerY: s32,
    pub scaleX: s32,
    pub scaleY: s32,
    pub scrollX: s32,
    pub scrollY: s32,
    pub size: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub dirty: bool,
}
#[test]
fn bindgen_test_layout_BgState() {
    assert_eq!(
        ::core::mem::size_of::<BgState>(),
        40usize,
        concat!("Size of: ", stringify!(BgState))
    );
    assert_eq!(
        ::core::mem::align_of::<BgState>(),
        4usize,
        concat!("Alignment of ", stringify!(BgState))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BgState>())).angle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BgState),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BgState>())).centerX as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BgState),
            "::",
            stringify!(centerX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BgState>())).centerY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BgState),
            "::",
            stringify!(centerY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BgState>())).scaleX as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BgState),
            "::",
            stringify!(scaleX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BgState>())).scaleY as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BgState),
            "::",
            stringify!(scaleY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BgState>())).scrollX as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BgState),
            "::",
            stringify!(scrollX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BgState>())).scrollY as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BgState),
            "::",
            stringify!(scrollY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BgState>())).size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BgState),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BgState>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BgState),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BgState>())).dirty as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BgState),
            "::",
            stringify!(dirty)
        )
    );
}
extern "C" {
    pub static mut bgControl: [*mut vuint16; 8usize];
}
extern "C" {
    pub static mut bgScrollTable: [*mut bg_scroll; 8usize];
}
extern "C" {
    pub static mut bgTransform: [*mut bg_transform; 8usize];
}
extern "C" {
    pub static mut bgState: [BgState; 8usize];
}
#[doc = "!< 8bpp Tiled background with 16 bit tile indexes and no allowed rotation or scaling"]
pub const BgType_Text8bpp: BgType = 0;
#[doc = "!< 4bpp Tiled background with 16 bit tile indexes and no allowed rotation or scaling"]
pub const BgType_Text4bpp: BgType = 1;
#[doc = "!< Tiled background with 8 bit tile indexes Can be scaled and rotated"]
pub const BgType_Rotation: BgType = 2;
#[doc = "!< Tiled background with 16 bit tile indexes Can be scaled and rotated"]
pub const BgType_ExRotation: BgType = 3;
#[doc = "!< Bitmap background with 8 bit color values which index into a 256 color palette"]
pub const BgType_Bmp8: BgType = 4;
#[doc = "!< Bitmap background with 16 bit color values of the form aBBBBBGGGGGRRRRR (if 'a' is set the pixel will be rendered...if not the pixel will be transparent)"]
pub const BgType_Bmp16: BgType = 5;
#[doc = "! Allowed background types, used in bgInit and bgInitSub."]
pub type BgType = u32;
#[doc = "< 128 x 128 pixel rotation background"]
pub const BgSize_R_128x128: BgSize = 0;
#[doc = "< 256 x 256 pixel rotation background"]
pub const BgSize_R_256x256: BgSize = 16384;
#[doc = "< 512 x 512 pixel rotation background"]
pub const BgSize_R_512x512: BgSize = 32768;
#[doc = "< 1024 x 1024 pixel rotation background"]
pub const BgSize_R_1024x1024: BgSize = 49152;
#[doc = "< 256 x 256 pixel text background"]
pub const BgSize_T_256x256: BgSize = 65536;
#[doc = "< 512 x 256 pixel text background"]
pub const BgSize_T_512x256: BgSize = 81920;
#[doc = "< 256 x 512 pixel text background"]
pub const BgSize_T_256x512: BgSize = 98304;
#[doc = "< 512 x 512 pixel text background"]
pub const BgSize_T_512x512: BgSize = 114688;
#[doc = "< 128 x 128 pixel extended rotation background"]
pub const BgSize_ER_128x128: BgSize = 131072;
#[doc = "< 256 x 256 pixel extended rotation background"]
pub const BgSize_ER_256x256: BgSize = 147456;
#[doc = "< 512 x 512 pixel extended rotation background"]
pub const BgSize_ER_512x512: BgSize = 163840;
#[doc = "< 1024 x 1024 extended pixel rotation background"]
pub const BgSize_ER_1024x1024: BgSize = 180224;
#[doc = "< 128 x 128 pixel 8 bit bitmap background"]
pub const BgSize_B8_128x128: BgSize = 196736;
#[doc = "< 256 x 256 pixel 8 bit bitmap background"]
pub const BgSize_B8_256x256: BgSize = 213120;
#[doc = "< 512 x 256 pixel 8 bit bitmap background"]
pub const BgSize_B8_512x256: BgSize = 229504;
#[doc = "< 512 x 512 pixel 8 bit bitmap background"]
pub const BgSize_B8_512x512: BgSize = 245888;
#[doc = "< 1024 x 512 pixel 8 bit bitmap background"]
pub const BgSize_B8_1024x512: BgSize = 212992;
#[doc = "< 512 x 1024 pixel 8 bit bitmap background"]
pub const BgSize_B8_512x1024: BgSize = 196608;
#[doc = "< 128 x 128 pixel 16 bit bitmap background"]
pub const BgSize_B16_128x128: BgSize = 262276;
#[doc = "< 256 x 256 pixel 16 bit bitmap background"]
pub const BgSize_B16_256x256: BgSize = 278660;
#[doc = "< 512 x 512 pixel 16 bit bitmap background"]
pub const BgSize_B16_512x256: BgSize = 295044;
#[doc = "< 1024 x 1024 pixel 16 bit bitmap background"]
pub const BgSize_B16_512x512: BgSize = 311428;
#[doc = " \\brief Allowed background Sizes"]
#[doc = " The lower 16 bits of these defines can be used directly to set the background control register bits"]
#[doc = " \\ingroup api_group"]
pub type BgSize = u32;
extern "C" {
    pub fn bgIsText(id: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn bgInit_call(
        layer: ::std::os::raw::c_int,
        type_: BgType,
        size: BgSize,
        mapBase: ::std::os::raw::c_int,
        tileBase: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bgInitSub_call(
        layer: ::std::os::raw::c_int,
        type_: BgType,
        size: BgSize,
        mapBase: ::std::os::raw::c_int,
        tileBase: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\brief Must be called once per frame to update scroll/scale/and rotation of backgrounds."]
    pub fn bgUpdate();
}
extern "C" {
    pub fn IC_InvalidateAll();
}
extern "C" {
    pub fn IC_InvalidateRange(base: *const ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DC_FlushAll();
}
extern "C" {
    pub fn DC_FlushRange(base: *const ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DC_InvalidateAll();
}
extern "C" {
    pub fn DC_InvalidateRange(base: *const ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn sinLerp(angle: s16) -> s16;
}
extern "C" {
    pub fn cosLerp(angle: s16) -> s16;
}
extern "C" {
    pub fn tanLerp(angle: s16) -> s32;
}
extern "C" {
    pub fn asinLerp(par: s16) -> s16;
}
extern "C" {
    pub fn acosLerp(par: s16) -> s16;
}
pub type fixed12d3 = uint16;
pub type t16 = ::std::os::raw::c_short;
pub type v16 = ::std::os::raw::c_short;
pub type v10 = ::std::os::raw::c_short;
pub type rgb = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct m3x3 {
    pub m: [::std::os::raw::c_int; 9usize],
}
#[test]
fn bindgen_test_layout_m3x3() {
    assert_eq!(
        ::core::mem::size_of::<m3x3>(),
        36usize,
        concat!("Size of: ", stringify!(m3x3))
    );
    assert_eq!(
        ::core::mem::align_of::<m3x3>(),
        4usize,
        concat!("Alignment of ", stringify!(m3x3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<m3x3>())).m as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(m3x3), "::", stringify!(m))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct m4x4 {
    pub m: [::std::os::raw::c_int; 16usize],
}
#[test]
fn bindgen_test_layout_m4x4() {
    assert_eq!(
        ::core::mem::size_of::<m4x4>(),
        64usize,
        concat!("Size of: ", stringify!(m4x4))
    );
    assert_eq!(
        ::core::mem::align_of::<m4x4>(),
        4usize,
        concat!("Alignment of ", stringify!(m4x4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<m4x4>())).m as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(m4x4), "::", stringify!(m))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct m4x3 {
    pub m: [::std::os::raw::c_int; 12usize],
}
#[test]
fn bindgen_test_layout_m4x3() {
    assert_eq!(
        ::core::mem::size_of::<m4x3>(),
        48usize,
        concat!("Size of: ", stringify!(m4x3))
    );
    assert_eq!(
        ::core::mem::align_of::<m4x3>(),
        4usize,
        concat!("Alignment of ", stringify!(m4x3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<m4x3>())).m as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(m4x3), "::", stringify!(m))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLvector {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GLvector() {
    assert_eq!(
        ::core::mem::size_of::<GLvector>(),
        12usize,
        concat!("Size of: ", stringify!(GLvector))
    );
    assert_eq!(
        ::core::mem::align_of::<GLvector>(),
        4usize,
        concat!("Alignment of ", stringify!(GLvector))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GLvector>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GLvector),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GLvector>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GLvector),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GLvector>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GLvector),
            "::",
            stringify!(z)
        )
    );
}
pub const GL_TRIANGLES: GL_GLBEGIN_ENUM = 0;
pub const GL_QUADS: GL_GLBEGIN_ENUM = 1;
pub const GL_TRIANGLE_STRIP: GL_GLBEGIN_ENUM = 2;
pub const GL_QUAD_STRIP: GL_GLBEGIN_ENUM = 3;
pub const GL_TRIANGLE: GL_GLBEGIN_ENUM = 0;
pub const GL_QUAD: GL_GLBEGIN_ENUM = 1;
pub type GL_GLBEGIN_ENUM = u32;
pub const GL_PROJECTION: GL_MATRIX_MODE_ENUM = 0;
pub const GL_POSITION: GL_MATRIX_MODE_ENUM = 1;
pub const GL_MODELVIEW: GL_MATRIX_MODE_ENUM = 2;
pub const GL_TEXTURE: GL_MATRIX_MODE_ENUM = 3;
pub type GL_MATRIX_MODE_ENUM = u32;
pub const GL_AMBIENT: GL_MATERIALS_ENUM = 1;
pub const GL_DIFFUSE: GL_MATERIALS_ENUM = 2;
pub const GL_AMBIENT_AND_DIFFUSE: GL_MATERIALS_ENUM = 3;
pub const GL_SPECULAR: GL_MATERIALS_ENUM = 4;
pub const GL_SHININESS: GL_MATERIALS_ENUM = 8;
pub const GL_EMISSION: GL_MATERIALS_ENUM = 16;
pub type GL_MATERIALS_ENUM = u32;
pub const POLY_FORMAT_LIGHT0: GL_POLY_FORMAT_ENUM = 1;
pub const POLY_FORMAT_LIGHT1: GL_POLY_FORMAT_ENUM = 2;
pub const POLY_FORMAT_LIGHT2: GL_POLY_FORMAT_ENUM = 4;
pub const POLY_FORMAT_LIGHT3: GL_POLY_FORMAT_ENUM = 8;
pub const POLY_MODULATION: GL_POLY_FORMAT_ENUM = 0;
pub const POLY_DECAL: GL_POLY_FORMAT_ENUM = 16;
pub const POLY_TOON_HIGHLIGHT: GL_POLY_FORMAT_ENUM = 32;
pub const POLY_SHADOW: GL_POLY_FORMAT_ENUM = 48;
pub const POLY_CULL_FRONT: GL_POLY_FORMAT_ENUM = 64;
pub const POLY_CULL_BACK: GL_POLY_FORMAT_ENUM = 128;
pub const POLY_CULL_NONE: GL_POLY_FORMAT_ENUM = 192;
pub const POLY_FOG: GL_POLY_FORMAT_ENUM = 32768;
pub type GL_POLY_FORMAT_ENUM = u32;
pub const TEXTURE_SIZE_8: GL_TEXTURE_SIZE_ENUM = 0;
pub const TEXTURE_SIZE_16: GL_TEXTURE_SIZE_ENUM = 1;
pub const TEXTURE_SIZE_32: GL_TEXTURE_SIZE_ENUM = 2;
pub const TEXTURE_SIZE_64: GL_TEXTURE_SIZE_ENUM = 3;
pub const TEXTURE_SIZE_128: GL_TEXTURE_SIZE_ENUM = 4;
pub const TEXTURE_SIZE_256: GL_TEXTURE_SIZE_ENUM = 5;
pub const TEXTURE_SIZE_512: GL_TEXTURE_SIZE_ENUM = 6;
pub const TEXTURE_SIZE_1024: GL_TEXTURE_SIZE_ENUM = 7;
pub type GL_TEXTURE_SIZE_ENUM = u32;
pub const GL_TEXTURE_WRAP_S: GL_TEXTURE_PARAM_ENUM = 65536;
pub const GL_TEXTURE_WRAP_T: GL_TEXTURE_PARAM_ENUM = 131072;
pub const GL_TEXTURE_FLIP_S: GL_TEXTURE_PARAM_ENUM = 262144;
pub const GL_TEXTURE_FLIP_T: GL_TEXTURE_PARAM_ENUM = 524288;
pub const GL_TEXTURE_COLOR0_TRANSPARENT: GL_TEXTURE_PARAM_ENUM = 536870912;
pub const TEXGEN_OFF: GL_TEXTURE_PARAM_ENUM = 0;
pub const TEXGEN_TEXCOORD: GL_TEXTURE_PARAM_ENUM = 1073741824;
pub const TEXGEN_NORMAL: GL_TEXTURE_PARAM_ENUM = -2147483648;
pub const TEXGEN_POSITION: GL_TEXTURE_PARAM_ENUM = -1073741824;
pub type GL_TEXTURE_PARAM_ENUM = i32;
pub const GL_NOTEXTURE: GL_TEXTURE_TYPE_ENUM = 0;
pub const GL_RGB32_A3: GL_TEXTURE_TYPE_ENUM = 1;
pub const GL_RGB4: GL_TEXTURE_TYPE_ENUM = 2;
pub const GL_RGB16: GL_TEXTURE_TYPE_ENUM = 3;
pub const GL_RGB256: GL_TEXTURE_TYPE_ENUM = 4;
pub const GL_COMPRESSED: GL_TEXTURE_TYPE_ENUM = 5;
pub const GL_RGB8_A5: GL_TEXTURE_TYPE_ENUM = 6;
pub const GL_RGBA: GL_TEXTURE_TYPE_ENUM = 7;
pub const GL_RGB: GL_TEXTURE_TYPE_ENUM = 8;
pub type GL_TEXTURE_TYPE_ENUM = u32;
pub const GL_COLOR_TABLE_FORMAT_EXT: GL_TEXTURE_PALETTE_PARAM_ENUM = 0;
pub const GL_COLOR_TABLE_WIDTH_EXT: GL_TEXTURE_PALETTE_PARAM_ENUM = 1;
pub type GL_TEXTURE_PALETTE_PARAM_ENUM = u32;
pub const GL_TEXTURE_2D: DISP3DCNT_ENUM = 1;
pub const GL_TOON_HIGHLIGHT: DISP3DCNT_ENUM = 2;
pub const GL_ALPHA_TEST: DISP3DCNT_ENUM = 4;
pub const GL_BLEND: DISP3DCNT_ENUM = 8;
pub const GL_ANTIALIAS: DISP3DCNT_ENUM = 16;
pub const GL_OUTLINE: DISP3DCNT_ENUM = 32;
pub const GL_FOG_ONLY_ALPHA: DISP3DCNT_ENUM = 64;
pub const GL_FOG: DISP3DCNT_ENUM = 128;
pub const GL_COLOR_UNDERFLOW: DISP3DCNT_ENUM = 4096;
pub const GL_POLY_OVERFLOW: DISP3DCNT_ENUM = 8192;
pub const GL_CLEAR_BMP: DISP3DCNT_ENUM = 16384;
pub type DISP3DCNT_ENUM = u32;
pub const GL_GET_VERTEX_RAM_COUNT: GL_GET_ENUM = 0;
pub const GL_GET_POLYGON_RAM_COUNT: GL_GET_ENUM = 1;
pub const GL_GET_MATRIX_VECTOR: GL_GET_ENUM = 2;
pub const GL_GET_MATRIX_POSITION: GL_GET_ENUM = 3;
pub const GL_GET_MATRIX_PROJECTION: GL_GET_ENUM = 4;
pub const GL_GET_MATRIX_CLIP: GL_GET_ENUM = 5;
pub const GL_GET_TEXTURE_WIDTH: GL_GET_ENUM = 6;
pub const GL_GET_TEXTURE_HEIGHT: GL_GET_ENUM = 7;
pub type GL_GET_ENUM = u32;
pub const GL_TRANS_MANUALSORT: GLFLUSH_ENUM = 1;
pub const GL_WBUFFERING: GLFLUSH_ENUM = 2;
pub type GLFLUSH_ENUM = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s_SingleBlock {
    pub indexOut: uint32,
    pub AddrSet: *mut uint8,
    pub node: [*mut s_SingleBlock; 4usize],
    pub blockSize: uint32,
}
#[test]
fn bindgen_test_layout_s_SingleBlock() {
    assert_eq!(
        ::core::mem::size_of::<s_SingleBlock>(),
        56usize,
        concat!("Size of: ", stringify!(s_SingleBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<s_SingleBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(s_SingleBlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_SingleBlock>())).indexOut as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(s_SingleBlock),
            "::",
            stringify!(indexOut)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_SingleBlock>())).AddrSet as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(s_SingleBlock),
            "::",
            stringify!(AddrSet)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_SingleBlock>())).node as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(s_SingleBlock),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_SingleBlock>())).blockSize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(s_SingleBlock),
            "::",
            stringify!(blockSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s_vramBlock {
    pub startAddr: *mut uint8,
    pub endAddr: *mut uint8,
    pub firstBlock: *mut s_SingleBlock,
    pub firstEmpty: *mut s_SingleBlock,
    pub firstAlloc: *mut s_SingleBlock,
    pub lastExamined: *mut s_SingleBlock,
    pub lastExaminedAddr: *mut uint8,
    pub lastExaminedSize: uint32,
    pub blockPtrs: DynamicArray,
    pub deallocBlocks: DynamicArray,
    pub blockCount: uint32,
    pub deallocCount: uint32,
}
#[test]
fn bindgen_test_layout_s_vramBlock() {
    assert_eq!(
        ::core::mem::size_of::<s_vramBlock>(),
        104usize,
        concat!("Size of: ", stringify!(s_vramBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<s_vramBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(s_vramBlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_vramBlock>())).startAddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(s_vramBlock),
            "::",
            stringify!(startAddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_vramBlock>())).endAddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(s_vramBlock),
            "::",
            stringify!(endAddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_vramBlock>())).firstBlock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(s_vramBlock),
            "::",
            stringify!(firstBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_vramBlock>())).firstEmpty as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(s_vramBlock),
            "::",
            stringify!(firstEmpty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_vramBlock>())).firstAlloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(s_vramBlock),
            "::",
            stringify!(firstAlloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_vramBlock>())).lastExamined as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(s_vramBlock),
            "::",
            stringify!(lastExamined)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_vramBlock>())).lastExaminedAddr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(s_vramBlock),
            "::",
            stringify!(lastExaminedAddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_vramBlock>())).lastExaminedSize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(s_vramBlock),
            "::",
            stringify!(lastExaminedSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_vramBlock>())).blockPtrs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(s_vramBlock),
            "::",
            stringify!(blockPtrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_vramBlock>())).deallocBlocks as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(s_vramBlock),
            "::",
            stringify!(deallocBlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_vramBlock>())).blockCount as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(s_vramBlock),
            "::",
            stringify!(blockCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<s_vramBlock>())).deallocCount as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(s_vramBlock),
            "::",
            stringify!(deallocCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gl_texture_data {
    pub vramAddr: *mut ::core::ffi::c_void,
    pub texIndex: uint32,
    pub texIndexExt: uint32,
    pub palIndex: ::std::os::raw::c_int,
    pub texFormat: uint32,
    pub texSize: uint32,
}
#[test]
fn bindgen_test_layout_gl_texture_data() {
    assert_eq!(
        ::core::mem::size_of::<gl_texture_data>(),
        32usize,
        concat!("Size of: ", stringify!(gl_texture_data))
    );
    assert_eq!(
        ::core::mem::align_of::<gl_texture_data>(),
        8usize,
        concat!("Alignment of ", stringify!(gl_texture_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_texture_data>())).vramAddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_texture_data),
            "::",
            stringify!(vramAddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_texture_data>())).texIndex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_texture_data),
            "::",
            stringify!(texIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_texture_data>())).texIndexExt as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_texture_data),
            "::",
            stringify!(texIndexExt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_texture_data>())).palIndex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_texture_data),
            "::",
            stringify!(palIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_texture_data>())).texFormat as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_texture_data),
            "::",
            stringify!(texFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_texture_data>())).texSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_texture_data),
            "::",
            stringify!(texSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gl_palette_data {
    pub vramAddr: *mut ::core::ffi::c_void,
    pub palIndex: uint32,
    pub addr: uint16,
    pub palSize: uint16,
    pub connectCount: uint32,
}
#[test]
fn bindgen_test_layout_gl_palette_data() {
    assert_eq!(
        ::core::mem::size_of::<gl_palette_data>(),
        24usize,
        concat!("Size of: ", stringify!(gl_palette_data))
    );
    assert_eq!(
        ::core::mem::align_of::<gl_palette_data>(),
        8usize,
        concat!("Alignment of ", stringify!(gl_palette_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_palette_data>())).vramAddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_palette_data),
            "::",
            stringify!(vramAddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_palette_data>())).palIndex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_palette_data),
            "::",
            stringify!(palIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_palette_data>())).addr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_palette_data),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_palette_data>())).palSize as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_palette_data),
            "::",
            stringify!(palSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_palette_data>())).connectCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_palette_data),
            "::",
            stringify!(connectCount)
        )
    );
}
#[repr(C)]
pub struct gl_hidden_globals {
    pub matrixMode: GL_MATRIX_MODE_ENUM,
    pub vramBlocks: [*mut s_vramBlock; 2usize],
    pub vramLock: [::std::os::raw::c_int; 2usize],
    pub texturePtrs: DynamicArray,
    pub palettePtrs: DynamicArray,
    pub deallocTex: DynamicArray,
    pub deallocPal: DynamicArray,
    pub deallocTexSize: uint32,
    pub deallocPalSize: uint32,
    pub activeTexture: ::std::os::raw::c_int,
    pub activePalette: ::std::os::raw::c_int,
    pub texCount: ::std::os::raw::c_int,
    pub palCount: ::std::os::raw::c_int,
    pub clearColor: u32,
    pub isActive: uint8,
}
#[test]
fn bindgen_test_layout_gl_hidden_globals() {
    assert_eq!(
        ::core::mem::size_of::<gl_hidden_globals>(),
        128usize,
        concat!("Size of: ", stringify!(gl_hidden_globals))
    );
    assert_eq!(
        ::core::mem::align_of::<gl_hidden_globals>(),
        8usize,
        concat!("Alignment of ", stringify!(gl_hidden_globals))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_hidden_globals>())).matrixMode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(matrixMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_hidden_globals>())).vramBlocks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(vramBlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_hidden_globals>())).vramLock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(vramLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_hidden_globals>())).texturePtrs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(texturePtrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_hidden_globals>())).palettePtrs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(palettePtrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_hidden_globals>())).deallocTex as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(deallocTex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_hidden_globals>())).deallocPal as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(deallocPal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gl_hidden_globals>())).deallocTexSize as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(deallocTexSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gl_hidden_globals>())).deallocPalSize as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(deallocPalSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gl_hidden_globals>())).activeTexture as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(activeTexture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gl_hidden_globals>())).activePalette as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(activePalette)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_hidden_globals>())).texCount as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(texCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_hidden_globals>())).palCount as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(palCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_hidden_globals>())).clearColor as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(clearColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gl_hidden_globals>())).isActive as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_hidden_globals),
            "::",
            stringify!(isActive)
        )
    );
}
extern "C" {
    pub static mut glGlobalData: gl_hidden_globals;
}
extern "C" {
    pub static mut glGlob: *mut gl_hidden_globals;
}
extern "C" {
    pub fn glRotatef32i(angle: ::std::os::raw::c_int, x: int32, y: int32, z: int32);
}
extern "C" {
    pub fn glTexImage2D(
        target: ::std::os::raw::c_int,
        empty1: ::std::os::raw::c_int,
        type_: GL_TEXTURE_TYPE_ENUM,
        sizeX: ::std::os::raw::c_int,
        sizeY: ::std::os::raw::c_int,
        empty2: ::std::os::raw::c_int,
        param: ::std::os::raw::c_int,
        texture: *const ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn glColorTableEXT(
        target: ::std::os::raw::c_int,
        empty1: ::std::os::raw::c_int,
        width: uint16,
        empty2: ::std::os::raw::c_int,
        empty3: ::std::os::raw::c_int,
        table: *const uint16,
    );
}
extern "C" {
    pub fn glColorSubTableEXT(
        target: ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        empty1: ::std::os::raw::c_int,
        empty2: ::std::os::raw::c_int,
        data: *const uint16,
    );
}
extern "C" {
    pub fn glGetColorTableEXT(
        target: ::std::os::raw::c_int,
        empty1: ::std::os::raw::c_int,
        empty2: ::std::os::raw::c_int,
        table: *mut uint16,
    );
}
extern "C" {
    pub fn glAssignColorTable(target: ::std::os::raw::c_int, name: ::std::os::raw::c_int);
}
extern "C" {
    pub fn glTexParameter(target: ::std::os::raw::c_int, param: ::std::os::raw::c_int);
}
extern "C" {
    pub fn glGetTexParameter() -> u32;
}
extern "C" {
    pub fn glGetColorTableParameterEXT(
        target: ::std::os::raw::c_int,
        pname: ::std::os::raw::c_int,
        params: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn glGetTexturePointer(name: ::std::os::raw::c_int) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn glBindTexture(target: ::std::os::raw::c_int, name: ::std::os::raw::c_int);
}
extern "C" {
    pub fn glGenTextures(
        n: ::std::os::raw::c_int,
        names: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn glDeleteTextures(
        n: ::std::os::raw::c_int,
        names: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn glResetTextures();
}
extern "C" {
    pub fn glLockVRAMBank(addr: *mut uint16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn glUnlockVRAMBank(addr: *mut uint16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn glTexCoord2f32(u: int32, v: int32);
}
extern "C" {
    pub fn glMaterialf(mode: GL_MATERIALS_ENUM, color: rgb);
}
extern "C" {
    pub fn glInit_C();
}
extern "C" {
    pub fn glGetGlobals() -> *mut gl_hidden_globals;
}
extern "C" {
    #[doc = "\t\\brief Performs a test to determine if the provided box is in the view frustrum."]
    #[doc = "\\param x (x, y, z) point of a vertex on the box"]
    #[doc = "\\param y (x, y, z) point of a vertex on the box"]
    #[doc = "\\param z (x, y, z) point of a vertex on the box"]
    #[doc = "\\param height (height, width, depth) describe the size of the box referenced from (x, y, z)"]
    #[doc = "\\param width (height, width, depth) describe the size of the box referenced from (x, y, z)"]
    #[doc = "\\param depth (height, width, depth) describe the size of the box referenced from (x, y, z)"]
    #[doc = ""]
    #[doc = "\\return non zero if any or all of the box is in the view frustum."]
    pub fn BoxTest(
        x: v16,
        y: v16,
        z: v16,
        width: v16,
        height: v16,
        depth: v16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\brief Performs a test to determine if the provided box is in the view frustum."]
    #[doc = "\\param x (x, y, z) point of a vertex on the box"]
    #[doc = "\\param y (x, y, z) point of a vertex on the box"]
    #[doc = "\\param z (x, y, z) point of a vertex on the box"]
    #[doc = "\\param width (width, height, depth) describe the size of the box referenced from (x, y, z)"]
    #[doc = "\\param height (width, height, depth) describe the size of the box referenced from (x, y, z)"]
    #[doc = "\\param depth (width, height, depth) describe the size of the box referenced from (x, y, z)"]
    #[doc = ""]
    #[doc = "\\return non zero if any or all of the box is in the view frustum."]
    pub fn BoxTestf(
        x: f32,
        y: f32,
        z: f32,
        width: f32,
        height: f32,
        depth: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\brief Performs a test to determine if the provided box is in the view frustum."]
    #[doc = "Performs a test to determine if the provided box is in the view frustum."]
    #[doc = "BoxTestResult must be called to get the result of this operation."]
    #[doc = ""]
    #[doc = "\\param x (x, y, z) point of a vertex on the box"]
    #[doc = "\\param y (x, y, z) point of a vertex on the box"]
    #[doc = "\\param z (x, y, z) point of a vertex on the box"]
    #[doc = "\\param width (width, height, depth) describe the size of the box referenced from (x, y, z)"]
    #[doc = "\\param height (width, height, depth) describe the size of the box referenced from (x, y, z)"]
    #[doc = "\\param depth (width, height, depth) describe the size of the box referenced from (x, y, z)"]
    pub fn BoxTest_Asynch(x: v16, y: v16, z: v16, height: v16, width: v16, depth: v16);
}
extern "C" {
    #[doc = "\t\\brief Performs a test to determine if the provided box is in the view frustum."]
    #[doc = "Performs a test to determine if the provided box is in the view frustum."]
    #[doc = "BoxTestResult must be called to get the result of this operation."]
    #[doc = ""]
    #[doc = "\\param x (x, y, z) point of a vertex on the box"]
    #[doc = "\\param y (x, y, z) point of a vertex on the box"]
    #[doc = "\\param z (x, y, z) point of a vertex on the box"]
    #[doc = "\\param width (width, height, depth) describe the size of the box referenced from (x, y, z)"]
    #[doc = "\\param height (width, height, depth) describe the size of the box referenced from (x, y, z)"]
    #[doc = "\\param depth (width, height, depth) describe the size of the box referenced from (x, y, z)"]
    pub fn BoxTestf_Asynch(x: f32, y: f32, z: f32, width: f32, height: f32, depth: f32);
}
extern "C" {
    #[doc = "\t\\brief Gets the result of the last box test. Needed for asynch box test calls."]
    #[doc = "\\return non zero if any or all of the box is in the view frustum."]
    pub fn BoxTestResult() -> ::std::os::raw::c_int;
}
pub type ConsolePrint = ::core::option::Option<
    unsafe extern "C" fn(con: *mut ::core::ffi::c_void, c: ::std::os::raw::c_char) -> bool,
>;
#[doc = "! a font struct for the console."]
#[repr(C)]
pub struct ConsoleFont {
    #[doc = "!< A pointer to the font graphics (will be loaded by consoleInit() if loadGraphics is true"]
    pub gfx: *mut u16,
    #[doc = "!< A pointer to the font palette (will be loaded by consoleInit() if loadGraphics is true"]
    pub pal: *mut u16,
    #[doc = "!< Number of colors in the font palette"]
    pub numColors: u16,
    #[doc = "!< Bits per pixel in the font graphics"]
    pub bpp: u8,
    #[doc = "!<  Offset to the first valid character in the font table"]
    pub asciiOffset: u16,
    #[doc = "!< Number of characters in the font graphics"]
    pub numChars: u16,
    #[doc = "< If true font is treated as a single color font where all non zero pixels are set to"]
    #[doc = "a value of 15 or 255 (4bpp / 8bpp respectivly)."]
    #[doc = "This ensures only one palette entry is utilized for font rendering."]
    pub convertSingleColor: bool,
}
#[test]
fn bindgen_test_layout_ConsoleFont() {
    assert_eq!(
        ::core::mem::size_of::<ConsoleFont>(),
        32usize,
        concat!("Size of: ", stringify!(ConsoleFont))
    );
    assert_eq!(
        ::core::mem::align_of::<ConsoleFont>(),
        8usize,
        concat!("Alignment of ", stringify!(ConsoleFont))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).gfx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(gfx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).pal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(pal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).numColors as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(numColors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).bpp as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).asciiOffset as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(asciiOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).numChars as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(numChars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).convertSingleColor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(convertSingleColor)
        )
    );
}
#[doc = " \\brief console structure used to store the state of a console render context."]
#[doc = ""]
#[doc = "Default values from consoleGetDefault();"]
#[doc = "<div class=\"fixedFont\"><pre>"]
#[doc = "PrintConsole defaultConsole ="]
#[doc = "{"]
#[doc = "{"]
#[doc = "(u16*)default_font_bin, //font gfx"]
#[doc = "0, //font palette"]
#[doc = "0, //font color count"]
#[doc = "4, //bpp"]
#[doc = "0, //first ascii character in the set"]
#[doc = "128, //number of characters in the font set"]
#[doc = "true, //convert to single color"]
#[doc = "},"]
#[doc = "0, //font background map"]
#[doc = "0, //font background gfx"]
#[doc = "31, //map base"]
#[doc = "0, //char base"]
#[doc = "0, //bg layer in use"]
#[doc = "-1, //bg id"]
#[doc = "0,0, //cursorX cursorY"]
#[doc = "0,0, //prevcursorX prevcursorY"]
#[doc = "32, //console width"]
#[doc = "24, //console height"]
#[doc = "0,  //window x"]
#[doc = "0,  //window y"]
#[doc = "32, //window width"]
#[doc = "24, //window height"]
#[doc = "3, //tab size"]
#[doc = "0, //font character offset"]
#[doc = "0, //selected palette"]
#[doc = "0,  //print callback"]
#[doc = "false, //console initialized"]
#[doc = "true, //load graphics"]
#[doc = "};"]
#[doc = "</pre></div>"]
#[repr(C)]
pub struct PrintConsole {
    #[doc = "!< font of the console."]
    pub font: ConsoleFont,
    #[doc = "< Pointer to the bg layer map if used.  Is set by bgInit if bgId is valid"]
    pub fontBgMap: *mut u16,
    #[doc = "< Pointer to the bg layer graphics if used.  Is set by bgInit if bgId is valid"]
    pub fontBgGfx: *mut u16,
    #[doc = "< Map base set by console init based on background setup"]
    pub mapBase: u8,
    #[doc = "< Tile graphics base set by console init based on background setup"]
    pub gfxBase: u8,
    #[doc = "< Bg layer used by the background"]
    pub bgLayer: u8,
    #[doc = "< bgId, should be set with a call to bgInit() or bgInitSub()"]
    pub bgId: ::std::os::raw::c_int,
    #[doc = "< Current X location of the cursor (as a tile offset by default)"]
    pub cursorX: ::std::os::raw::c_int,
    #[doc = "< Current Y location of the cursor (as a tile offset by default)"]
    pub cursorY: ::std::os::raw::c_int,
    #[doc = "< Internal state"]
    pub prevCursorX: ::std::os::raw::c_int,
    #[doc = "< Internal state"]
    pub prevCursorY: ::std::os::raw::c_int,
    #[doc = "< Width of the console hardware layer in tiles"]
    pub consoleWidth: ::std::os::raw::c_int,
    #[doc = "< Height of the console hardware layer in tiles"]
    pub consoleHeight: ::std::os::raw::c_int,
    #[doc = "< Window X location in tiles (not implemented)"]
    pub windowX: ::std::os::raw::c_int,
    #[doc = "< Window Y location in tiles (not implemented)"]
    pub windowY: ::std::os::raw::c_int,
    #[doc = "< Window width in tiles (not implemented)"]
    pub windowWidth: ::std::os::raw::c_int,
    #[doc = "< Window height in tiles (not implemented)"]
    pub windowHeight: ::std::os::raw::c_int,
    #[doc = "< Size of a tab"]
    pub tabSize: ::std::os::raw::c_int,
    #[doc = "< Offset to the first graphics tile in background memory (in case your font is not loaded at a graphics base boundary)"]
    pub fontCharOffset: u16,
    #[doc = "< The current palette used by the engine (only applies to 4bpp text backgrounds)"]
    pub fontCurPal: u16,
    #[doc = "< callback for printing a character. Should return true if it has handled rendering the graphics"]
    #[doc = "(else the print engine will attempt to render via tiles)"]
    pub PrintChar: ConsolePrint,
    #[doc = "< True if the console is initialized"]
    pub consoleInitialised: bool,
    #[doc = "< True if consoleInit should attempt to load font graphics into background memory"]
    pub loadGraphics: bool,
}
#[test]
fn bindgen_test_layout_PrintConsole() {
    assert_eq!(
        ::core::mem::size_of::<PrintConsole>(),
        120usize,
        concat!("Size of: ", stringify!(PrintConsole))
    );
    assert_eq!(
        ::core::mem::align_of::<PrintConsole>(),
        8usize,
        concat!("Alignment of ", stringify!(PrintConsole))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).font as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).fontBgMap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(fontBgMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).fontBgGfx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(fontBgGfx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).mapBase as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(mapBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).gfxBase as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(gfxBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).bgLayer as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(bgLayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).bgId as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(bgId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).cursorX as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(cursorX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).cursorY as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(cursorY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).prevCursorX as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(prevCursorX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).prevCursorY as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(prevCursorY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).consoleWidth as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(consoleWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).consoleHeight as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(consoleHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).windowX as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(windowX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).windowY as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(windowY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).windowWidth as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(windowWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).windowHeight as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(windowHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).tabSize as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(tabSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).fontCharOffset as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(fontCharOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).fontCurPal as *const _ as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(fontCurPal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).PrintChar as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(PrintChar)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PrintConsole>())).consoleInitialised as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(consoleInitialised)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).loadGraphics as *const _ as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(loadGraphics)
        )
    );
}
#[doc = "!< swallows prints to stderr"]
pub const DebugDevice_NULL: DebugDevice = 0;
#[doc = "!< Directs stderr debug statements to no$gba debug window"]
pub const DebugDevice_NOCASH: DebugDevice = 1;
#[doc = "!< Directs stderr debug statements to DS console window"]
pub const DebugDevice_CONSOLE: DebugDevice = 2;
#[doc = "! Console debug devices supported by libnds."]
pub type DebugDevice = u32;
extern "C" {
    #[doc = "\t\\brief Loads the font into the console"]
    #[doc = "\\param console pointer to the console to update, if NULL it will update the current console"]
    #[doc = "\\param font the font to load"]
    pub fn consoleSetFont(console: *mut PrintConsole, font: *mut ConsoleFont);
}
extern "C" {
    #[doc = "\t\\brief Sets the print window"]
    #[doc = "\\param console console to set, if NULL it will set the current console window"]
    #[doc = "\\param x x location of the window"]
    #[doc = "\\param y y location of the window"]
    #[doc = "\\param width width of the window"]
    #[doc = "\\param height height of the window"]
    pub fn consoleSetWindow(
        console: *mut PrintConsole,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\t\\brief Gets a pointer to the console with the default values"]
    #[doc = "this should only be used when using a single console or without changing the console that is returned, other wise use consoleInit()"]
    #[doc = "\\return A pointer to the console with the default values"]
    pub fn consoleGetDefault() -> *mut PrintConsole;
}
extern "C" {
    #[doc = "\t\\brief Make the specified console the render target"]
    #[doc = "\\param console A pointer to the console struct (must have been initialized with consoleInit(PrintConsole* console)"]
    #[doc = "\\return a pointer to the previous console"]
    pub fn consoleSelect(console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    #[doc = "\t\\brief Initialise the console."]
    #[doc = "\\param console A pointer to the console data to initialze (if it's NULL, the default console will be used)"]
    #[doc = "\\param layer background layer to use"]
    #[doc = "\\param type the type of the background"]
    #[doc = "\\param size the size of the background"]
    #[doc = "\\param mapBase the map base"]
    #[doc = "\\param tileBase the tile graphics base"]
    #[doc = "\\param mainDisplay if true main engine is used, otherwise false"]
    #[doc = "\\param loadGraphics if true the default font graphics will be loaded into the layer"]
    #[doc = "\\return A pointer to the current console."]
    pub fn consoleInit(
        console: *mut PrintConsole,
        layer: ::std::os::raw::c_int,
        type_: BgType,
        size: BgSize,
        mapBase: ::std::os::raw::c_int,
        tileBase: ::std::os::raw::c_int,
        mainDisplay: bool,
        loadGraphics: bool,
    ) -> *mut PrintConsole;
}
extern "C" {
    #[doc = "\t\\brief Initialize the console to a default state for prototyping."]
    #[doc = "This function sets the console to use sub display, VRAM_C, and BG0 and enables MODE_0_2D on the"]
    #[doc = "sub display.  It is intended for use in prototyping applications which need print ability and not actual"]
    #[doc = "game use.  Print functionality can be utilized with just this call."]
    #[doc = "\\return A pointer to the current PrintConsole."]
    pub fn consoleDemoInit() -> *mut PrintConsole;
}
extern "C" {
    #[doc = "! Clears the screan by using iprintf(\"\\x1b[2J\");"]
    pub fn consoleClear();
}
extern "C" {
    #[doc = "\t\\brief Initializes debug console output on stderr to the specified device"]
    #[doc = "\\param device The debug device (or devices) to output debug print statements to"]
    pub fn consoleDebugInit(device: DebugDevice);
}
#[doc = "!< LZ77 decompression."]
pub const LZ77: DecompressType = 0;
#[doc = "!< vram safe LZ77 decompression."]
pub const LZ77Vram: DecompressType = 1;
#[doc = "!< vram safe huff decompression."]
pub const HUFF: DecompressType = 2;
#[doc = "!< run length encoded decompression."]
pub const RLE: DecompressType = 3;
#[doc = "!< vram safe run length encoded decompression."]
pub const RLEVram: DecompressType = 4;
#[doc = "! the types of decompression available."]
pub type DecompressType = u32;
extern "C" {
    #[doc = "\\brief decompresses data using the suported type"]
    #[doc = "\\param dst the destination to decompress to"]
    #[doc = "\\param data the data to decompress"]
    #[doc = "\\param type the type of data to decompress"]
    pub fn decompress(
        data: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_void,
        type_: DecompressType,
    );
}
extern "C" {
    #[doc = "\\brief decompresses data using the suported type (only LZ77Vram, HUFF, and RLEVram support streaming)"]
    #[doc = "\\param dst the destination to decompress to."]
    #[doc = "\\param data the data to decompress."]
    #[doc = "\\param type the type of data to decompress."]
    #[doc = "\\param readCB a callback to read the next byte of data."]
    #[doc = "\\param getHeaderCB a callback to read the 32 byte header."]
    pub fn decompressStream(
        data: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_void,
        type_: DecompressType,
        readCB: getByteCallback,
        getHeaderCB: getHeaderCallback,
    );
}
extern "C" {
    pub static mut exceptionC: [VoidFn; 0usize];
}
extern "C" {
    pub static mut exceptionStack: u32;
}
extern "C" {
    pub static mut exceptionRegisters: [s32; 0usize];
}
extern "C" {
    pub fn enterException();
}
extern "C" {
    #[doc = "! sets a custom hardware exception handler."]
    pub fn setExceptionHandler(handler: VoidFn);
}
extern "C" {
    #[doc = "! sets the default hardware exception handler."]
    pub fn defaultExceptionHandler();
}
extern "C" {
    #[doc = "! returns the cpu status register."]
    pub fn getCPSR() -> u32;
}
extern "C" {
    #[doc = " \\fn bool guitarGripIsInserted()"]
    #[doc = "\\brief Check for the guitar grip"]
    #[doc = "\\return true if that's what is in the slot-2"]
    pub fn guitarGripIsInserted() -> bool;
}
extern "C" {
    #[doc = " \\fn void guitarGripScanKeys()"]
    #[doc = "\\brief Obtain the current guitar grip state."]
    #[doc = "Call this function once per main loop to use the guitarGrip functions."]
    pub fn guitarGripScanKeys();
}
extern "C" {
    #[doc = "! Obtains the current guitar grip keys held state"]
    pub fn guitarGripKeysHeld() -> u8;
}
extern "C" {
    #[doc = "! Obtains the current guitar grip keys pressed state"]
    pub fn guitarGripKeysDown() -> u16;
}
extern "C" {
    #[doc = "! Obtains the current guitar grip keys released state"]
    pub fn guitarGripKeysUp() -> u16;
}
#[doc = "!\t\\brief holds a red green blue triplet"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RGB_24 {
    #[doc = "!< 8 bits for the red value."]
    pub r: ::std::os::raw::c_uchar,
    #[doc = "!< 8 bits for the green value."]
    pub g: ::std::os::raw::c_uchar,
    #[doc = "!< 8 bits for the blue value."]
    pub b: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_RGB_24() {
    assert_eq!(
        ::core::mem::size_of::<RGB_24>(),
        3usize,
        concat!("Size of: ", stringify!(RGB_24))
    );
    assert_eq!(
        ::core::mem::align_of::<RGB_24>(),
        1usize,
        concat!("Alignment of ", stringify!(RGB_24))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RGB_24>())).r as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(RGB_24), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RGB_24>())).g as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(RGB_24), "::", stringify!(g))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RGB_24>())).b as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(RGB_24), "::", stringify!(b))
    );
}
#[doc = "!\tA generic image structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sImage {
    #[doc = "< \\brief The height of the image in pixels"]
    pub height: ::std::os::raw::c_short,
    #[doc = "< \\brief The width of the image in pixels"]
    pub width: ::std::os::raw::c_short,
    #[doc = "< \\brief Bits per pixel (should be 4 8 16 or 24)"]
    pub bpp: ::std::os::raw::c_int,
    #[doc = "< \\brief A pointer to the palette data"]
    pub palette: *mut ::std::os::raw::c_ushort,
    pub image: sImage__bindgen_ty_1,
}
#[doc = "! A union of data pointers to the pixel data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union sImage__bindgen_ty_1 {
    #[doc = "!< pointer to 8 bit data."]
    pub data8: *mut u8,
    #[doc = "!< pointer to 16 bit data."]
    pub data16: *mut u16,
    #[doc = "!< pointer to 32 bit data."]
    pub data32: *mut u32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sImage__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sImage__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sImage__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sImage__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sImage__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sImage__bindgen_ty_1>())).data8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sImage__bindgen_ty_1),
            "::",
            stringify!(data8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sImage__bindgen_ty_1>())).data16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sImage__bindgen_ty_1),
            "::",
            stringify!(data16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sImage__bindgen_ty_1>())).data32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sImage__bindgen_ty_1),
            "::",
            stringify!(data32)
        )
    );
}
#[test]
fn bindgen_test_layout_sImage() {
    assert_eq!(
        ::core::mem::size_of::<sImage>(),
        24usize,
        concat!("Size of: ", stringify!(sImage))
    );
    assert_eq!(
        ::core::mem::align_of::<sImage>(),
        8usize,
        concat!("Alignment of ", stringify!(sImage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sImage>())).height as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sImage),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sImage>())).width as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sImage),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sImage>())).bpp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sImage),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sImage>())).palette as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sImage),
            "::",
            stringify!(palette)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sImage>())).image as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sImage),
            "::",
            stringify!(image)
        )
    );
}
pub type psImage = *mut sImage;
extern "C" {
    #[doc = " \\brief Destructively converts a 24-bit image to 16-bit"]
    #[doc = "\\param img a pointer to image to manipulate"]
    pub fn image24to16(img: *mut sImage);
}
extern "C" {
    #[doc = " \\brief Destructively converts an 8-bit image to 16 bit setting the alpha bit"]
    #[doc = "\\param img a pointer to image to manipulate"]
    pub fn image8to16(img: *mut sImage);
}
extern "C" {
    #[doc = " \\brief Destructively converts an 8-bit image to 16-bit with alpha bit cleared for the supplied palette index"]
    #[doc = "\\param img a pointer to image to manipulate"]
    #[doc = "\\param transparentColor Color indexes equal to this value will have the alpha bit clear"]
    pub fn image8to16trans(img: *mut sImage, transparentColor: u8);
}
extern "C" {
    #[doc = " \\brief frees the image data. Only call if the image data was returned from an image loader"]
    #[doc = "\\param img a pointer to image to manipulate (the image data will be free() )"]
    pub fn imageDestroy(img: *mut sImage);
}
extern "C" {
    #[doc = " \\brief Tiles 8-bit image data into a sequence of 8x8 tiles"]
    #[doc = "\\param img a pointer to image to manipulate"]
    pub fn imageTileData(img: *mut sImage);
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct PCXHeader {
    pub manufacturer: ::std::os::raw::c_char,
    pub version: ::std::os::raw::c_char,
    pub encoding: ::std::os::raw::c_char,
    pub bitsPerPixel: ::std::os::raw::c_char,
    pub xmin: ::std::os::raw::c_short,
    pub ymin: ::std::os::raw::c_short,
    pub xmax: ::std::os::raw::c_short,
    pub ymax: ::std::os::raw::c_short,
    pub hres: ::std::os::raw::c_short,
    pub vres: ::std::os::raw::c_short,
    pub palette16: [::std::os::raw::c_char; 48usize],
    pub reserved: ::std::os::raw::c_char,
    pub colorPlanes: ::std::os::raw::c_char,
    pub bytesPerLine: ::std::os::raw::c_short,
    pub paletteYype: ::std::os::raw::c_short,
    pub filler: [::std::os::raw::c_char; 58usize],
}
#[test]
fn bindgen_test_layout_PCXHeader() {
    assert_eq!(
        ::core::mem::size_of::<PCXHeader>(),
        128usize,
        concat!("Size of: ", stringify!(PCXHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<PCXHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(PCXHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).manufacturer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(manufacturer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).version as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).encoding as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).bitsPerPixel as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(bitsPerPixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).xmin as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(xmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).ymin as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(ymin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).xmax as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(xmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).ymax as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(ymax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).hres as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(hres)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).vres as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(vres)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).palette16 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(palette16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).reserved as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).colorPlanes as *const _ as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(colorPlanes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).bytesPerLine as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(bytesPerLine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).paletteYype as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(paletteYype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PCXHeader>())).filler as *const _ as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(PCXHeader),
            "::",
            stringify!(filler)
        )
    );
}
pub type pPCXHeader = *mut PCXHeader;
extern "C" {
    pub fn loadPCX(
        pcx: *const ::std::os::raw::c_uchar,
        image: *mut sImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\brief Obtains the current keypad state."]
    #[doc = "Call this function once per main loop in order to use the keypad functions."]
    pub fn scanKeys();
}
extern "C" {
    #[doc = "\t\\brief Obtains the current keypad state."]
    #[doc = "Call this function to get keypad state without affecting state of other key functions (keysUp keysHeld etc...)"]
    pub fn keysCurrent() -> uint32;
}
extern "C" {
    #[doc = "!\tObtains the current keypad held state."]
    pub fn keysHeld() -> uint32;
}
extern "C" {
    #[doc = "!\tObtains the current keypad pressed state."]
    pub fn keysDown() -> uint32;
}
extern "C" {
    #[doc = "!\tObtains the current keypad pressed or repeating state."]
    pub fn keysDownRepeat() -> uint32;
}
extern "C" {
    #[doc = "\t\\brief Sets the key repeat parameters."]
    #[doc = "\\param setDelay Number of %scanKeys calls before keys start to repeat."]
    #[doc = "\\param setRepeat Number of %scanKeys calls before keys repeat."]
    pub fn keysSetRepeat(setDelay: u8, setRepeat: u8);
}
extern "C" {
    #[doc = "! Obtains the current keypad released state."]
    pub fn keysUp() -> uint32;
}
extern "C" {
    pub fn touchReadXY() -> touchPosition;
}
extern "C" {
    #[doc = "\\brief Obtains the current touchpad state."]
    #[doc = "\\param data a touchPosition ptr which will be filled by the function."]
    pub fn touchRead(data: *mut touchPosition);
}
#[doc = "!callback function pointer for a key changed."]
pub type KeyChangeCallback =
    ::core::option::Option<unsafe extern "C" fn(key: ::std::os::raw::c_int)>;
#[doc = "< Normal keyboard display (lowercase letters)"]
pub const Lower: KeyboardState = 0;
#[doc = "< Caps lock Held"]
pub const Upper: KeyboardState = 1;
#[doc = "< Numeric only keypad (not provided by the default keyboard)"]
pub const Numeric: KeyboardState = 2;
#[doc = "< Reduced footprint keyboard (not provided by the default keyboard)"]
pub const Reduced: KeyboardState = 3;
#[doc = "! States the keyboard can be in, currently only Lower and Upper supported."]
pub type KeyboardState = u32;
#[doc = "! defines a key mapping."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KeyMap {
    #[doc = "< the map for keys pressed"]
    pub mapDataPressed: *const u16,
    #[doc = "< the map for keys released"]
    pub mapDataReleased: *const u16,
    #[doc = "< the lookup table for x y grid location to corresponding key"]
    pub keymap: *const ::std::os::raw::c_int,
    #[doc = "< width of the keyboard in grid spaces"]
    pub width: ::std::os::raw::c_int,
    #[doc = "< height of the keyboard in grid spaces"]
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_KeyMap() {
    assert_eq!(
        ::core::mem::size_of::<KeyMap>(),
        32usize,
        concat!("Size of: ", stringify!(KeyMap))
    );
    assert_eq!(
        ::core::mem::align_of::<KeyMap>(),
        8usize,
        concat!("Alignment of ", stringify!(KeyMap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KeyMap>())).mapDataPressed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyMap),
            "::",
            stringify!(mapDataPressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KeyMap>())).mapDataReleased as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyMap),
            "::",
            stringify!(mapDataReleased)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KeyMap>())).keymap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyMap),
            "::",
            stringify!(keymap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KeyMap>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyMap),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KeyMap>())).height as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyMap),
            "::",
            stringify!(height)
        )
    );
}
#[doc = "! describes a keyboard."]
#[repr(C)]
pub struct Keyboard {
    #[doc = "< Background number to use, after init() this contains the background ID"]
    pub background: ::std::os::raw::c_int,
    #[doc = "< boolean to determine if keyboard is on sub screen or main"]
    pub keyboardOnSub: ::std::os::raw::c_int,
    #[doc = "< x offset of the map, can be used to center a custom keyboard"]
    pub offset_x: ::std::os::raw::c_int,
    #[doc = "< y offset of the map, can be used to center a custom keyboard"]
    pub offset_y: ::std::os::raw::c_int,
    #[doc = "< the grid width, this size will be used to translate x coordinate of touch to x coordinate in keymap"]
    pub grid_width: ::std::os::raw::c_int,
    #[doc = "< the grid height, this size will be used to translate y coordinate of touch to y coordinate in keymap"]
    pub grid_height: ::std::os::raw::c_int,
    #[doc = "< the state of the keyboard"]
    pub state: KeyboardState,
    #[doc = "< true if shifted"]
    pub shifted: ::std::os::raw::c_int,
    #[doc = "< true if visible"]
    pub visible: ::std::os::raw::c_int,
    #[doc = "!< array of 4 keymap pointers, one for every keyboard state."]
    pub mappings: [*mut KeyMap; 4usize],
    #[doc = "< pointer to graphics tiles, cannot exceed 44KB with default base"]
    pub tiles: *const u16,
    #[doc = "< length in bytes of graphics data"]
    pub tileLen: u32,
    #[doc = "< pointer to the palette"]
    pub palette: *const u16,
    #[doc = "< length in bytes of the palette data"]
    pub paletteLen: u32,
    #[doc = "< map base to be used by the keyboard"]
    pub mapBase: ::std::os::raw::c_int,
    #[doc = "< tile base to be used by keyboard graphics"]
    pub tileBase: ::std::os::raw::c_int,
    #[doc = "< tile offset (in bytes) to load graphics (map must be preadjusted)"]
    pub tileOffset: ::std::os::raw::c_int,
    #[doc = "<keyboard scroll speed on hide and show in pixels per frame (must be positive and 0 == instant on)"]
    pub scrollSpeed: u32,
    #[doc = "< will be called on key press"]
    pub OnKeyPressed: KeyChangeCallback,
    #[doc = "< will be called on key release"]
    pub OnKeyReleased: KeyChangeCallback,
}
#[test]
fn bindgen_test_layout_Keyboard() {
    assert_eq!(
        ::core::mem::size_of::<Keyboard>(),
        136usize,
        concat!("Size of: ", stringify!(Keyboard))
    );
    assert_eq!(
        ::core::mem::align_of::<Keyboard>(),
        8usize,
        concat!("Alignment of ", stringify!(Keyboard))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).background as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).keyboardOnSub as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(keyboardOnSub)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).offset_x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(offset_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).offset_y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(offset_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).grid_width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(grid_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).grid_height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(grid_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).state as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).shifted as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(shifted)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).visible as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(visible)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).mappings as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(mappings)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).tiles as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(tiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).tileLen as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(tileLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).palette as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(palette)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).paletteLen as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(paletteLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).mapBase as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(mapBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).tileBase as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(tileBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).tileOffset as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(tileOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).scrollSpeed as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(scrollSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).OnKeyPressed as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(OnKeyPressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Keyboard>())).OnKeyReleased as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Keyboard),
            "::",
            stringify!(OnKeyReleased)
        )
    );
}
#[doc = "!< will be returned if no key was pressed."]
pub const NOKEY: Keys = -1;
#[doc = "!< will be returned if the fold key was pressed (topleft on the default keyboard)."]
pub const DVK_FOLD: Keys = -23;
#[doc = "!< will be returned if the tab key was pressed."]
pub const DVK_TAB: Keys = 9;
#[doc = "!< will be returned if the backspace key was pressed."]
pub const DVK_BACKSPACE: Keys = 8;
#[doc = "!< will be returned if the caps key was pressed."]
pub const DVK_CAPS: Keys = -15;
#[doc = "!< will be returned if the shift key was pressed."]
pub const DVK_SHIFT: Keys = -14;
#[doc = "!< will be returned if the space key was pressed."]
pub const DVK_SPACE: Keys = 32;
#[doc = "!< will be returned if the menu key was pressed."]
pub const DVK_MENU: Keys = -5;
#[doc = "!< will be returned if the enter key was pressed."]
pub const DVK_ENTER: Keys = 10;
#[doc = "!< will be returned if the ctrl key was pressed."]
pub const DVK_CTRL: Keys = -16;
#[doc = "!< will be returned if the up key was pressed."]
pub const DVK_UP: Keys = -17;
#[doc = "!< will be returned if the right key was pressed."]
pub const DVK_RIGHT: Keys = -18;
#[doc = "!< will be returned if the down key was pressed."]
pub const DVK_DOWN: Keys = -19;
#[doc = "!< will be returned if the left key was pressed."]
pub const DVK_LEFT: Keys = -20;
#[doc = "!< will be returned if the alt key was pressed."]
pub const DVK_ALT: Keys = -26;
#[doc = "\t\\brief enum values for the keyboard control keys."]
#[doc = "negative values are keys with no sensible ascii representation."]
#[doc = "numbers are chosen to mimic ascii control sequences."]
pub type Keys = i32;
extern "C" {
    #[doc = "! Gets the default keyboard."]
    pub fn keyboardGetDefault() -> *mut Keyboard;
}
extern "C" {
    #[doc = "\t\\brief initializes the keyboard system with the supplied keyboard"]
    #[doc = "\\param keyboard the keyboard struct to initialize (can be NULL)"]
    #[doc = "\\param layer the background layer to use"]
    #[doc = "\\param type the background type to initialize"]
    #[doc = "\\param size the background size to initialize"]
    #[doc = "\\param mapBase the map base to use for the background"]
    #[doc = "\\param tileBase the graphics tile base to use for the background"]
    #[doc = "\\param mainDisplay if true the keyboard will render on the main display"]
    #[doc = "\\param loadGraphics if true the keyboard graphics will be loaded"]
    #[doc = "\\return returns the initialized keyboard struct"]
    pub fn keyboardInit(
        keyboard: *mut Keyboard,
        layer: ::std::os::raw::c_int,
        type_: BgType,
        size: BgSize,
        mapBase: ::std::os::raw::c_int,
        tileBase: ::std::os::raw::c_int,
        mainDisplay: bool,
        loadGraphics: bool,
    ) -> *mut Keyboard;
}
extern "C" {
    #[doc = "\t\\brief initializes the keyboard with default options."]
    #[doc = "Same as calling keyboardInit(NULL, 3, BgType_Text4bpp, BgSize_T_256x512, 20, 0, false, true)"]
    #[doc = "\\return a pointer to the current keyboard."]
    pub fn keyboardDemoInit() -> *mut Keyboard;
}
extern "C" {
    #[doc = "\t\\brief Displays the keyboard."]
    pub fn keyboardShow();
}
extern "C" {
    #[doc = "\t\\brief Hides the keyboard"]
    pub fn keyboardHide();
}
extern "C" {
    #[doc = "\t\\brief returns the ascii code for the key located at the supplied x and y."]
    #[doc = "Will not effect keyboard shift state."]
    #[doc = "\\param x the pixel x location"]
    #[doc = "\\param y the pixel y location"]
    #[doc = "\\return the key pressed or NOKEY if user pressed outside the keypad"]
    pub fn keyboardGetKey(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\brief reads the input until a the return key is pressed or the maxLen is exceeded."]
    #[doc = "\\param buffer a buffer to hold the input string"]
    #[doc = "\\param maxLen the maximum length to read"]
    pub fn keyboardGetString(buffer: *mut ::std::os::raw::c_char, maxLen: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\t\\brief Waits for user to press a key and returns the key pressed."]
    #[doc = "Use keyboardUpdate instead for async operation."]
    pub fn keyboardGetChar() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\brief Processes the keyboard."]
    #[doc = "Should be called once per frame when using the keyboard in an async manner."]
    #[doc = "\\return the ascii code of the key pressed or -1 if no key was pressed."]
    pub fn keyboardUpdate() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn bool paddleIsInserted()"]
    #[doc = "\\brief Check for the paddle"]
    #[doc = "\\return true if that's what is in the slot-2"]
    pub fn paddleIsInserted() -> bool;
}
extern "C" {
    #[doc = " \\fn void paddleRead()"]
    #[doc = "\\brief Obtain the current paddle state"]
    #[doc = "\\return a u16 containing a 12bit number (fixed point fraction), incrementing for clockwise rotations and decrementing for counterclockwise"]
    pub fn paddleRead() -> u16;
}
extern "C" {
    #[doc = "! Resets the paddle device. May change the current value to 0xFFF, 0x000, or 0x001. May perform other unknown internal reset operations. Normally not needed."]
    pub fn paddleReset();
}
extern "C" {
    #[doc = " \\fn bool pianoIsInserted()"]
    #[doc = "\\brief Check for piano option pack."]
    #[doc = "\\return true if the cart in the GBA slot is the piano option pack."]
    pub fn pianoIsInserted() -> bool;
}
extern "C" {
    #[doc = " \\fn void pianoScanKeys()"]
    #[doc = "\\brief Obtain the current piano state."]
    #[doc = "Call this function once per main loop to use the piano functions."]
    pub fn pianoScanKeys();
}
extern "C" {
    #[doc = "! Obtains the current piano keys held state"]
    pub fn pianoKeysHeld() -> u16;
}
extern "C" {
    #[doc = "! Obtains the current piano keys pressed state"]
    pub fn pianoKeysDown() -> u16;
}
extern "C" {
    #[doc = "! Obtains the current piano keys released state"]
    pub fn pianoKeysUp() -> u16;
}
pub const RUMBLE: RUMBLE_TYPE = 0;
pub const WARIOWARE: RUMBLE_TYPE = 1;
pub type RUMBLE_TYPE = u32;
extern "C" {
    #[doc = " \\fn bool isRumbleInserted(void);"]
    #[doc = "\\brief Check for rumble option pak."]
    #[doc = "\\return true if the cart in the GBA slot is a Rumble option pak."]
    pub fn isRumbleInserted() -> bool;
}
extern "C" {
    #[doc = " \\fn void setRumble(bool position);"]
    #[doc = "\\param position Alternates position of the actuator in the pak"]
    #[doc = "\\brief Fires the rumble actuator."]
    pub fn setRumble(position: bool);
}
pub type MicCallback = ::core::option::Option<
    unsafe extern "C" fn(completedBuffer: *mut ::core::ffi::c_void, length: ::std::os::raw::c_int),
>;
#[doc = "<  16-bit PCM"]
pub const SoundFormat_16Bit: SoundFormat = 1;
#[doc = "<  8-bit PCM"]
pub const SoundFormat_8Bit: SoundFormat = 0;
#[doc = "<  PSG (programmable sound generator?)"]
pub const SoundFormat_PSG: SoundFormat = 3;
#[doc = "<  IMA ADPCM compressed audio"]
pub const SoundFormat_ADPCM: SoundFormat = 2;
#[doc = " \\brief Sound formats used by the DS"]
pub type SoundFormat = u32;
#[doc = "<  8-bit PCM"]
pub const MicFormat_8Bit: MicFormat = 1;
#[doc = "<  12-bit PCM"]
pub const MicFormat_12Bit: MicFormat = 0;
#[doc = " \\brief Microphone recording formats DS"]
pub type MicFormat = u32;
#[doc = "<  0.0% duty cycle"]
pub const DutyCycle_0: DutyCycle = 7;
#[doc = "<  12.5% duty cycle"]
pub const DutyCycle_12: DutyCycle = 0;
#[doc = "<  25.0% duty cycle"]
pub const DutyCycle_25: DutyCycle = 1;
#[doc = "<  37.5% duty cycle"]
pub const DutyCycle_37: DutyCycle = 2;
#[doc = "<  50.0% duty cycle"]
pub const DutyCycle_50: DutyCycle = 3;
#[doc = "<  62.5% duty cycle"]
pub const DutyCycle_62: DutyCycle = 4;
#[doc = "<  75.0% duty cycle"]
pub const DutyCycle_75: DutyCycle = 5;
#[doc = "<  87.5% duty cycle"]
pub const DutyCycle_87: DutyCycle = 6;
#[doc = " \\brief PSG Duty cycles used by the PSG hardware"]
pub type DutyCycle = u32;
extern "C" {
    #[doc = " \\fn void soundEnable(void)"]
    #[doc = "\\brief Enables Sound on the DS.  Should be called prior to"]
    #[doc = "attempting sound playback"]
    pub fn soundEnable();
}
extern "C" {
    #[doc = " \\fn void soundDisable(void)"]
    #[doc = "\\brief Disables Sound on the DS."]
    pub fn soundDisable();
}
extern "C" {
    #[doc = " \\fn int soundPlaySample(const void* data, SoundFormat format, u32 dataSize, u16 freq, u8 volume, u8 pan, bool loop, u16 loopPoint);"]
    #[doc = "\\brief Plays a sound in the specified format at the specified frequency."]
    #[doc = ""]
    #[doc = "\\param data A pointer to the sound data"]
    #[doc = "\\param format The format of the data (only 16-bit and 8-bit pcm and ADPCM formats are supported by this function)"]
    #[doc = "\\param dataSize The size in bytes of the sound data"]
    #[doc = "\\param freq The frequency in Hz of the sample"]
    #[doc = "\\param volume The channel volume.  0 to 127 (min to max)"]
    #[doc = "\\param pan The channel pan 0 to 127 (left to right with 64 being centered)"]
    #[doc = "\\param loop If true, the sample will loop playing once then repeating starting at the offset stored in loopPoint"]
    #[doc = "\\param loopPoint The offset for the sample loop to restart when repeating"]
    #[doc = "\\return An integer id coresponding to the channel of playback.  This value can be used to pause, resume, or kill the sound"]
    #[doc = "as well as adjust volume, pan, and frequency"]
    pub fn soundPlaySample(
        data: *const ::core::ffi::c_void,
        format: SoundFormat,
        dataSize: u32,
        freq: u16,
        volume: u8,
        pan: u8,
        loop_: bool,
        loopPoint: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int soundPlayPSG(DutyCycle cycle, u16 freq, u8 volume, u8 pan);"]
    #[doc = "\\brief Pause a tone with the specified properties"]
    #[doc = "\\param cycle The DutyCycle of the sound wave"]
    #[doc = "\\param freq The frequency in Hz of the sample"]
    #[doc = "\\param volume The channel volume.  0 to 127 (min to max)"]
    #[doc = "\\param pan The channel pan 0 to 127 (left to right with 64 being centered)"]
    #[doc = "\\return An integer id coresponding to the channel of playback.  This value can be used to pause, resume, or kill the sound"]
    #[doc = "as well as adjust volume, pan, and frequency"]
    pub fn soundPlayPSG(cycle: DutyCycle, freq: u16, volume: u8, pan: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn int soundPlayNoise(u16 freq, u8 volume, u8 pan);"]
    #[doc = "\\brief Plays white noise with the specified parameters"]
    #[doc = "\\param freq The frequency in Hz of the sample"]
    #[doc = "\\param volume The channel volume.  0 to 127 (min to max)"]
    #[doc = "\\param pan The channel pan 0 to 127 (left to right with 64 being centered)"]
    #[doc = "\\return An integer id coresponding to the channel of playback.  This value can be used to pause, resume, or kill the sound"]
    #[doc = "as well as adjust volume, pan, and frequency"]
    pub fn soundPlayNoise(freq: u16, volume: u8, pan: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn void soundPause(int soundId)"]
    #[doc = "\\brief Pause the sound specified by soundId"]
    #[doc = "\\param soundId The sound ID returned by play sound"]
    pub fn soundPause(soundId: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\fn void soundSetWaveDuty(int soundId, DutyCycle cycle)"]
    #[doc = "\\brief Sets the Wave Duty of a PSG sound"]
    #[doc = "\\param soundId The sound ID returned by play sound"]
    #[doc = "\\param cycle The DutyCycle of the sound wave"]
    pub fn soundSetWaveDuty(soundId: ::std::os::raw::c_int, cycle: DutyCycle);
}
extern "C" {
    #[doc = " \\fn void soundKill(int soundId)"]
    #[doc = "\\brief Stops the sound specified by soundId and frees any resources allocated"]
    #[doc = "\\param soundId The sound ID returned by play sound"]
    pub fn soundKill(soundId: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\fn void soundResume(int soundId)"]
    #[doc = "\\brief Resumes a paused sound"]
    #[doc = "\\param soundId The sound ID returned by play sound"]
    pub fn soundResume(soundId: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\fn void soundSetVolume(int soundId, u8 volume)"]
    #[doc = "\\brief Sets the sound volume"]
    #[doc = "\\param soundId The sound ID returned by play sound"]
    #[doc = "\\param volume The new volume (0 to 127 min to max)"]
    pub fn soundSetVolume(soundId: ::std::os::raw::c_int, volume: u8);
}
extern "C" {
    #[doc = " \\fn void soundSetPan(int soundId, u8 pan)"]
    #[doc = "\\brief Sets the sound pan"]
    #[doc = "\\param soundId The sound ID returned by play sound"]
    #[doc = "\\param pan The new pan value (0 to 127 left to right (64 = center))"]
    pub fn soundSetPan(soundId: ::std::os::raw::c_int, pan: u8);
}
extern "C" {
    #[doc = " \\fn void soundSetFreq(int soundId, u16 freq)"]
    #[doc = "\\brief Sets the sound frequency"]
    #[doc = "\\param soundId The sound ID returned by play sound"]
    #[doc = "\\param freq The frequency in Hz"]
    pub fn soundSetFreq(soundId: ::std::os::raw::c_int, freq: u16);
}
extern "C" {
    #[doc = " \\fn int soundMicRecord(void *buffer, u32 bufferLength, MicFormat format, int freq, MicCallback callback);"]
    #[doc = ""]
    #[doc = "\\brief Starts a microphone recording to a double buffer specified by buffer"]
    #[doc = "\\param buffer A pointer to the start of the double buffer"]
    #[doc = "\\param bufferLength The length of the buffer in bytes (both halfs of the double buffer)"]
    #[doc = "\\param format Microphone can record in 8 or 12 bit format.  12 bit is shifted up to 16 bit pcm"]
    #[doc = "\\param freq The sample frequency"]
    #[doc = "\\param callback This will be called every time the buffer is full or half full"]
    #[doc = ""]
    #[doc = "\\return Returns non zero for success."]
    pub fn soundMicRecord(
        buffer: *mut ::core::ffi::c_void,
        bufferLength: u32,
        format: MicFormat,
        freq: ::std::os::raw::c_int,
        callback: MicCallback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\fn void soundMicOff(void)"]
    #[doc = "\\brief Stops the microphone from recording"]
    pub fn soundMicOff();
}
#[doc = "< No special mode is on - Normal sprite state."]
pub const OBJMODE_NORMAL: ObjBlendMode = 0;
#[doc = "< Color blending is on - Sprite can use HW blending features."]
pub const OBJMODE_BLENDED: ObjBlendMode = 1;
#[doc = "< Sprite can be seen only inside the sprite window."]
pub const OBJMODE_WINDOWED: ObjBlendMode = 2;
#[doc = "< Sprite is not using tiles - per pixel image data."]
pub const OBJMODE_BITMAP: ObjBlendMode = 3;
#[doc = " \\brief The blending mode of the sprite"]
pub type ObjBlendMode = u32;
#[doc = "< Sprite shape is NxN (Height == Width)."]
pub const OBJSHAPE_SQUARE: ObjShape = 0;
#[doc = "< Sprite shape is NxM with N > M (Height < Width)."]
pub const OBJSHAPE_WIDE: ObjShape = 1;
#[doc = "< Sprite shape is NxM with N < M (Height > Width)."]
pub const OBJSHAPE_TALL: ObjShape = 2;
#[doc = "< Sprite shape is undefined."]
pub const OBJSHAPE_FORBIDDEN: ObjShape = 3;
#[doc = " \\brief The shape of the sprite"]
pub type ObjShape = u32;
#[doc = "< Major sprite size is 8px."]
pub const OBJSIZE_8: ObjSize = 0;
#[doc = "< Major sprite size is 16px."]
pub const OBJSIZE_16: ObjSize = 1;
#[doc = "< Major sprite size is 32px."]
pub const OBJSIZE_32: ObjSize = 2;
#[doc = "< Major sprite size is 64px."]
pub const OBJSIZE_64: ObjSize = 3;
#[doc = " \\brief The size of the sprite"]
pub type ObjSize = u32;
#[doc = "< sprite has 16 colors."]
pub const OBJCOLOR_16: ObjColMode = 0;
#[doc = "< sprite has 256 colors."]
pub const OBJCOLOR_256: ObjColMode = 1;
#[doc = " \\brief The color mode of the sprite"]
pub type ObjColMode = u32;
#[doc = "< sprite priority level 0 - highest."]
pub const OBJPRIORITY_0: ObjPriority = 0;
#[doc = "< sprite priority level 1."]
pub const OBJPRIORITY_1: ObjPriority = 1;
#[doc = "< sprite priority level 2."]
pub const OBJPRIORITY_2: ObjPriority = 2;
#[doc = "< sprite priority level 3 - lowest."]
pub const OBJPRIORITY_3: ObjPriority = 3;
#[doc = " \\brief The priority of the sprite"]
pub type ObjPriority = u32;
#[doc = "! A bitfield of sprite attribute goodness...ugly to look at but not so bad to use."]
#[repr(C)]
pub struct SpriteEntry {
    pub __bindgen_anon_1: __BindgenUnionField<SpriteEntry__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<SpriteEntry__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 6usize],
}
#[repr(C)]
pub struct SpriteEntry__bindgen_ty_1 {
    pub __bindgen_anon_1: SpriteEntry__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: SpriteEntry__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: SpriteEntry__bindgen_ty_1__bindgen_ty_3,
    pub attribute3: u16,
}
#[repr(C)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_anon_1: SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1:
        __BindgenUnionField<SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2:
        __BindgenUnionField<SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: u32,
}
#[repr(C, packed)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn isHidden(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isHidden(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isHidden: bool) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isHidden: u8 = unsafe { ::core::mem::transmute(isHidden) };
            isHidden as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn isRotateScale(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isRotateScale(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isSizeDouble(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isSizeDouble(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blendMode(&self) -> ObjBlendMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_blendMode(&mut self, val: ObjBlendMode) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn isMosaic(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isMosaic(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn colorMode(&self) -> ObjColMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_colorMode(&mut self, val: ObjColMode) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shape(&self) -> ObjShape {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_shape(&mut self, val: ObjShape) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isRotateScale: bool,
        isSizeDouble: bool,
        blendMode: ObjBlendMode,
        isMosaic: bool,
        colorMode: ObjColMode,
        shape: ObjShape,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isRotateScale: u8 = unsafe { ::core::mem::transmute(isRotateScale) };
            isRotateScale as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isSizeDouble: u8 = unsafe { ::core::mem::transmute(isSizeDouble) };
            isSizeDouble as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let blendMode: u32 = unsafe { ::core::mem::transmute(blendMode) };
            blendMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isMosaic: u8 = unsafe { ::core::mem::transmute(isMosaic) };
            isMosaic as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let colorMode: u32 = unsafe { ::core::mem::transmute(colorMode) };
            colorMode as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let shape: u32 = unsafe { ::core::mem::transmute(shape) };
            shape as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout_SpriteEntry__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn y(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_y(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(y: u16) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let y: u16 = unsafe { ::core::mem::transmute(y) };
            y as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_2 {
    pub __bindgen_anon_1:
        __BindgenUnionField<SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>,
    pub __bindgen_anon_2:
        __BindgenUnionField<SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[repr(align(2))]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn x(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_x(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(x: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let x: u16 = unsafe { ::core::mem::transmute(x) };
            x as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_anon_1: SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<
        SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    >,
    pub __bindgen_anon_2: __BindgenUnionField<
        SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    >,
    pub bindgen_union_field: u32,
}
#[repr(C, packed)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::core::mem::size_of::<
            SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(
                SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::core::mem::align_of::<
            SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn hFlip(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hFlip(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vFlip(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vFlip(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(hFlip: bool, vFlip: bool) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hFlip: u8 = unsafe { ::core::mem::transmute(hFlip) };
            hFlip as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let vFlip: u8 = unsafe { ::core::mem::transmute(vFlip) };
            vFlip as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2(
) {
    assert_eq!(
        ::core::mem::size_of::<
            SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(
                SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2
            )
        )
    );
    assert_eq!(
        ::core::mem::align_of::<
            SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2
            )
        )
    );
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn rotationIndex(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_rotationIndex(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> ObjSize {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: ObjSize) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rotationIndex: u8,
        size: ObjSize,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let rotationIndex: u8 = unsafe { ::core::mem::transmute(rotationIndex) };
            rotationIndex as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let size: u32 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout_SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
        )
    );
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SpriteEntry__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_SpriteEntry__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SpriteEntry__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SpriteEntry__bindgen_ty_1__bindgen_ty_3)
        )
    );
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn gfxIndex(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u16) }
    }
    #[inline]
    pub fn set_gfxIndex(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn priority(&self) -> ObjPriority {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: ObjPriority) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn palette(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_palette(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        gfxIndex: u16,
        priority: ObjPriority,
        palette: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let gfxIndex: u16 = unsafe { ::core::mem::transmute(gfxIndex) };
            gfxIndex as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let priority: u32 = unsafe { ::core::mem::transmute(priority) };
            priority as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let palette: u8 = unsafe { ::core::mem::transmute(palette) };
            palette as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SpriteEntry__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SpriteEntry__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(SpriteEntry__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SpriteEntry__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SpriteEntry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SpriteEntry__bindgen_ty_1>())).attribute3 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SpriteEntry__bindgen_ty_1),
            "::",
            stringify!(attribute3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpriteEntry__bindgen_ty_2 {
    pub attribute: [uint16; 3usize],
    pub filler: uint16,
}
#[test]
fn bindgen_test_layout_SpriteEntry__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<SpriteEntry__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(SpriteEntry__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<SpriteEntry__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(SpriteEntry__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SpriteEntry__bindgen_ty_2>())).attribute as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SpriteEntry__bindgen_ty_2),
            "::",
            stringify!(attribute)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SpriteEntry__bindgen_ty_2>())).filler as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SpriteEntry__bindgen_ty_2),
            "::",
            stringify!(filler)
        )
    );
}
#[test]
fn bindgen_test_layout_SpriteEntry() {
    assert_eq!(
        ::core::mem::size_of::<SpriteEntry>(),
        24usize,
        concat!("Size of: ", stringify!(SpriteEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<SpriteEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(SpriteEntry))
    );
}
pub type pSpriteEntry = *mut SpriteEntry;
#[doc = "! A sprite rotation entry."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpriteRotation {
    pub filler1: [uint16; 3usize],
    #[doc = "< The change in x per horizontal pixel"]
    pub hdx: int16,
    pub filler2: [uint16; 3usize],
    #[doc = "< The change in y per horizontal pixel"]
    pub vdx: int16,
    pub filler3: [uint16; 3usize],
    #[doc = "< The change in x per vertical pixel"]
    pub hdy: int16,
    pub filler4: [uint16; 3usize],
    #[doc = "< The change in y per vertical pixel"]
    pub vdy: int16,
}
#[test]
fn bindgen_test_layout_SpriteRotation() {
    assert_eq!(
        ::core::mem::size_of::<SpriteRotation>(),
        32usize,
        concat!("Size of: ", stringify!(SpriteRotation))
    );
    assert_eq!(
        ::core::mem::align_of::<SpriteRotation>(),
        2usize,
        concat!("Alignment of ", stringify!(SpriteRotation))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SpriteRotation>())).filler1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SpriteRotation),
            "::",
            stringify!(filler1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SpriteRotation>())).hdx as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SpriteRotation),
            "::",
            stringify!(hdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SpriteRotation>())).filler2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SpriteRotation),
            "::",
            stringify!(filler2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SpriteRotation>())).vdx as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SpriteRotation),
            "::",
            stringify!(vdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SpriteRotation>())).filler3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SpriteRotation),
            "::",
            stringify!(filler3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SpriteRotation>())).hdy as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SpriteRotation),
            "::",
            stringify!(hdy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SpriteRotation>())).filler4 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SpriteRotation),
            "::",
            stringify!(filler4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SpriteRotation>())).vdy as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SpriteRotation),
            "::",
            stringify!(vdy)
        )
    );
}
pub type pSpriteRotation = *mut SpriteRotation;
#[repr(C)]
pub struct OAMTable {
    pub oamBuffer: __BindgenUnionField<[SpriteEntry; 128usize]>,
    pub matrixBuffer: __BindgenUnionField<[SpriteRotation; 32usize]>,
    pub bindgen_union_field: [u32; 768usize],
}
#[test]
fn bindgen_test_layout_OAMTable() {
    assert_eq!(
        ::core::mem::size_of::<OAMTable>(),
        3072usize,
        concat!("Size of: ", stringify!(OAMTable))
    );
    assert_eq!(
        ::core::mem::align_of::<OAMTable>(),
        4usize,
        concat!("Alignment of ", stringify!(OAMTable))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OAMTable>())).oamBuffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OAMTable),
            "::",
            stringify!(oamBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OAMTable>())).matrixBuffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OAMTable),
            "::",
            stringify!(matrixBuffer)
        )
    );
}
#[doc = "!< 8x8"]
pub const SpriteSize_8x8: SpriteSize = 2;
#[doc = "!< 16x16"]
pub const SpriteSize_16x16: SpriteSize = 16392;
#[doc = "!< 32x32"]
pub const SpriteSize_32x32: SpriteSize = 32800;
#[doc = "!< 64x64"]
pub const SpriteSize_64x64: SpriteSize = 49280;
#[doc = "!< 16x8"]
pub const SpriteSize_16x8: SpriteSize = 4100;
#[doc = "!< 32x8"]
pub const SpriteSize_32x8: SpriteSize = 20488;
#[doc = "!< 32x16"]
pub const SpriteSize_32x16: SpriteSize = 36880;
#[doc = "!< 64x32"]
pub const SpriteSize_64x32: SpriteSize = 53312;
#[doc = "!< 8x16"]
pub const SpriteSize_8x16: SpriteSize = 8196;
#[doc = "!< 8x32"]
pub const SpriteSize_8x32: SpriteSize = 24584;
#[doc = "!< 16x32"]
pub const SpriteSize_16x32: SpriteSize = 40976;
#[doc = "!< 32x64"]
pub const SpriteSize_32x64: SpriteSize = 57408;
#[doc = "! Enumerates all sizes supported by the 2D engine."]
pub type SpriteSize = u32;
#[doc = "< 1D tile mapping 32 byte boundary between offset"]
pub const SpriteMapping_1D_32: SpriteMapping = 16;
#[doc = "< 1D tile mapping 64 byte boundary between offset"]
pub const SpriteMapping_1D_64: SpriteMapping = 269484049;
#[doc = "< 1D tile mapping 128 byte boundary between offset"]
pub const SpriteMapping_1D_128: SpriteMapping = 538968082;
#[doc = "< 1D tile mapping 256 byte boundary between offset"]
pub const SpriteMapping_1D_256: SpriteMapping = 808452115;
#[doc = "< 2D tile mapping 32 byte boundary between offset"]
pub const SpriteMapping_2D: SpriteMapping = 1073741824;
#[doc = "< 1D bitmap mapping 128 byte boundary between offset"]
pub const SpriteMapping_Bmp_1D_128: SpriteMapping = 1344274514;
#[doc = "< 1D bitmap mapping 256 byte boundary between offset"]
pub const SpriteMapping_Bmp_1D_256: SpriteMapping = 1617952851;
#[doc = "< 2D bitmap mapping 128 pixels wide bitmap"]
pub const SpriteMapping_Bmp_2D_128: SpriteMapping = 1879048194;
#[doc = "< 2D bitmap mapping 256 pixels wide bitmap"]
pub const SpriteMapping_Bmp_2D_256: SpriteMapping = -2147483613;
#[doc = "! Graphics memory layout options."]
pub type SpriteMapping = i32;
#[doc = "< 16 colors per sprite"]
pub const SpriteColorFormat_16Color: SpriteColorFormat = 0;
#[doc = "< 256 colors per sprite"]
pub const SpriteColorFormat_256Color: SpriteColorFormat = 1;
#[doc = "< 16-bit sprites"]
pub const SpriteColorFormat_Bmp: SpriteColorFormat = 3;
#[doc = "! Color formats for sprite graphics."]
pub type SpriteColorFormat = u32;
#[repr(C)]
pub struct AllocHeader {
    pub nextFree: u16,
    pub size: u16,
}
#[test]
fn bindgen_test_layout_AllocHeader() {
    assert_eq!(
        ::core::mem::size_of::<AllocHeader>(),
        4usize,
        concat!("Size of: ", stringify!(AllocHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<AllocHeader>(),
        2usize,
        concat!("Alignment of ", stringify!(AllocHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AllocHeader>())).nextFree as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AllocHeader),
            "::",
            stringify!(nextFree)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AllocHeader>())).size as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AllocHeader),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "\t\\brief Holds the state for a 2D sprite engine."]
#[doc = "There are two of these objects, oamMain and oamSub and these must be passed in to all oam functions."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OamState {
    #[doc = "< The distance between tiles as 2^gfxOffsetStep"]
    pub gfxOffsetStep: ::std::os::raw::c_int,
    #[doc = "< pointer to the first free block of tiles"]
    pub firstFree: s16,
    #[doc = "< array, allocation buffer for graphics allocation"]
    pub allocBuffer: *mut AllocHeader,
    #[doc = "< current size of the allocation buffer"]
    pub allocBufferSize: s16,
    pub __bindgen_anon_1: OamState__bindgen_ty_1,
    #[doc = "!< the mapping of the oam."]
    pub spriteMapping: SpriteMapping,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OamState__bindgen_ty_1 {
    #[doc = "< pointer to shadow oam memory"]
    pub oamMemory: *mut SpriteEntry,
    #[doc = "< pointer to shadow oam memory for rotation"]
    pub oamRotationMemory: *mut SpriteRotation,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_OamState__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OamState__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(OamState__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OamState__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(OamState__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OamState__bindgen_ty_1>())).oamMemory as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OamState__bindgen_ty_1),
            "::",
            stringify!(oamMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OamState__bindgen_ty_1>())).oamRotationMemory as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OamState__bindgen_ty_1),
            "::",
            stringify!(oamRotationMemory)
        )
    );
}
#[test]
fn bindgen_test_layout_OamState() {
    assert_eq!(
        ::core::mem::size_of::<OamState>(),
        40usize,
        concat!("Size of: ", stringify!(OamState))
    );
    assert_eq!(
        ::core::mem::align_of::<OamState>(),
        8usize,
        concat!("Alignment of ", stringify!(OamState))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OamState>())).gfxOffsetStep as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OamState),
            "::",
            stringify!(gfxOffsetStep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OamState>())).firstFree as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OamState),
            "::",
            stringify!(firstFree)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OamState>())).allocBuffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OamState),
            "::",
            stringify!(allocBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OamState>())).allocBufferSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OamState),
            "::",
            stringify!(allocBufferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OamState>())).spriteMapping as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OamState),
            "::",
            stringify!(spriteMapping)
        )
    );
}
extern "C" {
    pub static mut oamMain: OamState;
}
extern "C" {
    pub static mut oamSub: OamState;
}
extern "C" {
    #[doc = "    \\brief convert a VRAM address to an oam offset"]
    #[doc = "    \\param oam must be: &oamMain or &oamSub"]
    #[doc = "    \\param offset the video memory address of the sprite graphics (not an offset)"]
    pub fn oamGfxPtrToOffset(
        oam: *mut OamState,
        offset: *const ::core::ffi::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "    \\brief Initializes the 2D sprite engine  In order to mix tiled and bitmap sprites"]
    #[doc = "use SpriteMapping_Bmp_1D_128 or SpriteMapping_Bmp_1D_256.  This will set mapping for both"]
    #[doc = "to 1D and give same sized boundaries so the sprite gfx allocation will function.  VBlank IRQ must"]
    #[doc = "be enabled for this function to work."]
    #[doc = "    \\param oam must be: &oamMain or &oamSub"]
    #[doc = "    \\param mapping the mapping mode"]
    #[doc = "    \\param extPalette if true the engine sets up extended palettes for 8bpp sprites"]
    pub fn oamInit(oam: *mut OamState, mapping: SpriteMapping, extPalette: bool);
}
extern "C" {
    #[doc = "    \\brief Disables sprite rendering"]
    #[doc = "    \\param oam must be: &oamMain or &oamSub"]
    pub fn oamDisable(oam: *mut OamState);
}
extern "C" {
    #[doc = "    \\brief Enables sprite rendering"]
    #[doc = "    \\param oam must be: &oamMain or &oamSub"]
    pub fn oamEnable(oam: *mut OamState);
}
extern "C" {
    #[doc = "    \\brief translates an oam offset into a video ram address"]
    #[doc = "    \\param oam must be: &oamMain or &oamSub"]
    #[doc = "    \\param gfxOffsetIndex the index to compute"]
    #[doc = "    \\return the address in vram corresponding to the supplied offset"]
    pub fn oamGetGfxPtr(oam: *mut OamState, gfxOffsetIndex: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    #[doc = "    \\brief Allocates graphics memory for the supplied sprite attributes"]
    #[doc = "    \\param oam must be: &oamMain or &oamSub"]
    #[doc = "    \\param size the size of the sprite to allocate"]
    #[doc = "    \\param colorFormat the color format of the sprite"]
    #[doc = "    \\return the address in vram of the allocated sprite"]
    pub fn oamAllocateGfx(
        oam: *mut OamState,
        size: SpriteSize,
        colorFormat: SpriteColorFormat,
    ) -> *mut u16;
}
extern "C" {
    #[doc = "    \\brief free vram memory obtained with oamAllocateGfx."]
    #[doc = "    \\param oam must be: &oamMain or &oamSub"]
    #[doc = "    \\param gfxOffset a vram offset obtained from oamAllocateGfx"]
    pub fn oamFreeGfx(oam: *mut OamState, gfxOffset: *const ::core::ffi::c_void);
}
extern "C" {
    #[doc = "    \\brief sets an oam entry to the supplied values"]
    #[doc = "    \\param oam must be: &oamMain or &oamSub"]
    #[doc = "    \\param id the oam number to be set [0 - 127]"]
    #[doc = "    \\param x the x location of the sprite in pixels"]
    #[doc = "    \\param y the y location of the sprite in pixels"]
    #[doc = "\t \\param priority The sprite priority (0 to 3)"]
    #[doc = "    \\param palette_alpha the palette number for 4bpp and 8bpp (extended palette mode), or the alpha value for bitmap sprites (bitmap sprites must specify a value > 0 to display) [0-15]"]
    #[doc = "    \\param size the size of the sprite"]
    #[doc = "    \\param format the color format of the sprite"]
    #[doc = "    \\param gfxOffset the video memory address of the sprite graphics (not an offset)"]
    #[doc = "    \\param affineIndex affine index to use (if < 0 or > 31 the sprite will be unrotated)"]
    #[doc = "    \\param sizeDouble if affineIndex >= 0 this will be used to double the sprite size for rotation"]
    #[doc = "    \\param hide if non zero (true) the sprite will be hidden"]
    #[doc = "    \\param vflip flip the sprite vertically"]
    #[doc = "    \\param hflip flip the sprite horizontally"]
    #[doc = "\t \\param mosaic if true mosaic will be applied to the sprite"]
    pub fn oamSet(
        oam: *mut OamState,
        id: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
        palette_alpha: ::std::os::raw::c_int,
        size: SpriteSize,
        format: SpriteColorFormat,
        gfxOffset: *const ::core::ffi::c_void,
        affineIndex: ::std::os::raw::c_int,
        sizeDouble: bool,
        hide: bool,
        hflip: bool,
        vflip: bool,
        mosaic: bool,
    );
}
extern "C" {
    #[doc = "    \\brief Hides the sprites in the supplied range: if count is zero all 128 sprites will be hidden"]
    #[doc = "    \\param oam must be: &oamMain or &oamSub"]
    #[doc = "    \\param start The first index to clear"]
    #[doc = "    \\param count The number of sprites to clear"]
    pub fn oamClear(oam: *mut OamState, start: ::std::os::raw::c_int, count: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "    \\brief causes oam memory to be updated...must be called during vblank if using oam api"]
    #[doc = "    \\param oam must be: &oamMain or &oamSub"]
    pub fn oamUpdate(oam: *mut OamState);
}
extern "C" {
    #[doc = "    \\brief sets the specified rotation scale entry"]
    #[doc = "    \\param oam must be: &oamMain or &oamSub"]
    #[doc = "    \\param rotId the rotation entry to set"]
    #[doc = "    \\param angle the ccw angle to rotate [-32768 - 32767]"]
    #[doc = "    \\param sx the inverse scale factor in the x direction"]
    #[doc = "    \\param sy the inverse scale factor in the y direction"]
    pub fn oamRotateScale(
        oam: *mut OamState,
        rotId: ::std::os::raw::c_int,
        angle: ::std::os::raw::c_int,
        sx: ::std::os::raw::c_int,
        sy: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\\brief determines the number of fragments in the allocation engine"]
    #[doc = "\\param oam must be: &oamMain or &oamSub"]
    #[doc = "\\return the number of fragments."]
    pub fn oamCountFragments(oam: *mut OamState) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn oamAllocReset(oam: *mut OamState);
}
#[doc = "!< Window 0."]
pub const WINDOW_0: WINDOW = 8192;
#[doc = "!< Window 1"]
pub const WINDOW_1: WINDOW = 16384;
#[doc = "!< Object window"]
pub const WINDOW_OBJ: WINDOW = 32768;
#[doc = "!< Area outside all windows"]
pub const WINDOW_OUT: WINDOW = 65536;
#[doc = "\t\\brief the supported windows"]
pub type WINDOW = u32;
extern "C" {
    #[doc = "    \\brief Set the windows bounds"]
    #[doc = "    \\param window The window to set bounds on"]
    #[doc = "    \\param left The X coordinate of the left hand side of the rectangle"]
    #[doc = "    \\param top The Y coordinate of the top of the rectangle"]
    #[doc = "    \\param right The X coordinate of the right hand side of the rectangle"]
    #[doc = "    \\param bottom The Y coordinate of the bottom of the rectangle"]
    pub fn windowSetBounds(window: WINDOW, left: u8, top: u8, right: u8, bottom: u8);
}
extern "C" {
    #[doc = "    \\brief Set the windows bounds (Sub engine)"]
    #[doc = "    \\param window The window to set bounds on"]
    #[doc = "    \\param left The X coordinate of the left hand side of the rectangle"]
    #[doc = "    \\param top The Y coordinate of the top of the rectangle"]
    #[doc = "    \\param right The X coordinate of the right hand side of the rectangle"]
    #[doc = "    \\param bottom The Y coordinate of the bottom of the rectangle"]
    pub fn windowSetBoundsSub(window: WINDOW, left: u8, top: u8, right: u8, bottom: u8);
}
extern "C" {
    #[doc = "\t\\brief Enables the window on the supplied background."]
    #[doc = "\\param id"]
    #[doc = "background id returned from bgInit or bgInitSub"]
    #[doc = "\\param window"]
    #[doc = "the the window to enable"]
    pub fn bgWindowEnable(id: ::std::os::raw::c_int, window: WINDOW);
}
extern "C" {
    #[doc = "\t\\brief Disables the window on the supplied background."]
    #[doc = "\\param id"]
    #[doc = "background id returned from bgInit or bgInitSub"]
    #[doc = "\\param window"]
    #[doc = "the the window to disable"]
    pub fn bgWindowDisable(id: ::std::os::raw::c_int, window: WINDOW);
}
extern "C" {
    #[doc = "    \\brief Enables the specified window."]
    #[doc = "    \\param oam must be: &oamMain or &oamSub"]
    #[doc = "    \\param the window to enable"]
    pub fn oamWindowEnable(oam: *mut OamState, w: WINDOW);
}
extern "C" {
    #[doc = "    \\brief Disables the specified window."]
    #[doc = "    \\param oam must be: &oamMain or &oamSub"]
    #[doc = "    \\param the window to disable"]
    pub fn oamWindowDisable(oam: *mut OamState, w: WINDOW);
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_int;
pub type __sigset_t = ::std::os::raw::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::core::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type fd_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 1usize],
}
#[test]
fn bindgen_test_layout__types_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<_types_fd_set>(),
        8usize,
        concat!("Size of: ", stringify!(_types_fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<_types_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(_types_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_types_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_types_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn select(
        __n: ::std::os::raw::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ::std::os::raw::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type ulong = ::std::os::raw::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::std::os::raw::c_ulong;
pub type daddr_t = ::std::os::raw::c_long;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::core::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub stackaddr: *mut ::core::ffi::c_void,
    pub stacksize: ::std::os::raw::c_int,
    pub contentionscope: ::std::os::raw::c_int,
    pub inheritsched: ::std::os::raw::c_int,
    pub schedpolicy: ::std::os::raw::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).stackaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stackaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).stacksize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stacksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).contentionscope as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(contentionscope)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).inheritsched as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(inheritsched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).schedpolicy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedpolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).schedparam as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).detachstate as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(detachstate)
        )
    );
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub recursive: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutexattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).recursive as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(recursive)
        )
    );
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub clock: clock_t,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_condattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).clock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(clock)
        )
    );
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub init_executed: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_once_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_once_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_once_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_once_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_once_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_once_t>())).init_executed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(init_executed)
        )
    );
}
extern "C" {
    pub static mut environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn access(
        __path: *const ::std::os::raw::c_char,
        __amode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__secs: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmod(__path: *const ::std::os::raw::c_char, __mode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __path: *const ::std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn close(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
extern "C" {
    pub fn daemon(
        nochdir: ::std::os::raw::c_int,
        noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(
        __fildes: ::std::os::raw::c_int,
        __fildes2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlpe(
        __file: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __dirfd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(__fildes: ::std::os::raw::c_int, __mode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fildes: ::std::os::raw::c_int,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __dirfd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getentropy(arg1: *mut ::core::ffi::c_void, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getgroups(
        __gidsetsize: ::std::os::raw::c_int,
        __grouplist: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeereid(
        arg1: ::std::os::raw::c_int,
        arg2: *mut uid_t,
        arg3: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iruserok(
        raddr: ::std::os::raw::c_ulong,
        superuser: ::std::os::raw::c_int,
        ruser: *const ::std::os::raw::c_char,
        luser: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn issetugid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __path: *const ::std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __path1: *const ::std::os::raw::c_char,
        __path2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __dirfd1: ::std::os::raw::c_int,
        __path1: *const ::std::os::raw::c_char,
        __dirfd2: ::std::os::raw::c_int,
        __path2: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__nice_value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fildes: ::std::os::raw::c_int,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> off_t;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
        arg2: ::core::option::Option<unsafe extern "C" fn()>,
        arg3: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pipe(__fildes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::core::ffi::c_void,
        __nbytes: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::core::ffi::c_void,
        __nbytes: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::core::ffi::c_void,
        __nbyte: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport(__alport: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__path: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok(
        rhost: *const ::std::os::raw::c_char,
        superuser: ::std::os::raw::c_int,
        ruser: *const ::std::os::raw::c_char,
        luser: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__incr: isize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn setegid(__gid: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgroups(
        ngroups: ::std::os::raw::c_int,
        grouplist: *const gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(arg1: *const ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgid(__pid: pid_t, __pgid: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: gid_t, __egid: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: uid_t, __euid: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn setuid(__uid: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn tcgetpgrp(__fildes: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fildes: ::std::os::raw::c_int, __pgrp_id: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fildes: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn usleep(__useconds: useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::core::ffi::c_void,
        __nbyte: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optreset: ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(arg1: *const ::std::os::raw::c_char, __length: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ualarm(__useconds: useconds_t, __interval: useconds_t) -> useconds_t;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdtablesize(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlink(
        __name1: *const ::std::os::raw::c_char,
        __name2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __dirfd1: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nand_ReadSectors(
        sector: sec_t,
        numSectors: sec_t,
        buffer: *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    pub fn nand_WriteSectors(
        sector: sec_t,
        numSectors: sec_t,
        buffer: *const ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    pub fn nand_GetSize() -> isize;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::core::ffi::c_void,
        _size: ::std::os::raw::c_ulong,
        _n: ::std::os::raw::c_ulong,
        arg2: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::core::ffi::c_void,
        _size: ::std::os::raw::c_ulong,
        _n: ::std::os::raw::c_ulong,
        arg2: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fopen(
        _name: *const ::std::os::raw::c_char,
        _type: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(
        arg1: *mut FILE,
        arg2: off_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn diprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fiprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fiscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn viprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn viscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fgetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *mut fpos_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: ::std::os::raw::c_long,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _gets_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _remove_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const ::std::os::raw::c_char,
        _new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::core::ffi::c_void,
    pub reg_save_area: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
